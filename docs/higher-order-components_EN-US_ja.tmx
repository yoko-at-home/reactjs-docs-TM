<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.3.2_0_6a661c5e0" segtype="sentence" srclang="EN-US"/>
  <body>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>---
id: higher-order-components
title: Higher-Order Components
permalink: docs/higher-order-components.html
---</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>---
id: higher-order-components
title: 高階 (Higher-Order) コンポーネント
permalink: docs/higher-order-components.html
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A higher-order component (HOC) is an advanced technique in React for reusing component logic.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>高階コンポーネント (higher-order component; HOC) はコンポーネントのロジックを再利用するための React における応用テクニックです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>HOCs are not part of the React API, per se.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC それ自体は React の API の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They are a pattern that emerges from React's compositional nature.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC は、React のコンポジションの性質から生まれる設計パターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Concretely, **a higher-order component is a function that takes a component and returns a new component.**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>具体的には、**高階コンポーネントとは、あるコンポーネントを受け取って新規のコンポーネントを返すような関数です。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whereas a component transforms props into UI, a higher-order component transforms a component into another component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>コンポーネントが props を UI に変換するのに対して、高階コンポーネントはコンポーネントを別のコンポーネントに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>HOCs are common in third-party React libraries, such as Redux's [`connect`](https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect) and Relay's [`createFragmentContainer`](https://relay.dev/docs/v10.1.3/fragment-container/#createfragmentcontainer). In this document, we'll discuss why higher-order components are useful, and how to write your own.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC は Redux における [`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api/connect.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) や Relay における [`createFragmentContainer`](https://relay.dev/docs/v10.1.3/fragment-container/#createfragmentcontainer) のように、サードパーティ製の React ライブラリでは一般的なものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Use HOCs For Cross-Cutting Concerns {#use-hocs-for-cross-cutting-concerns}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>このドキュメントでは、なぜ高階コンポーネントが便利で、自身でどのように記述するのかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt; **Note**
&gt;
&gt; We previously recommended mixins as a way to handle cross-cutting concerns.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>## 横断的関心事に HOC を適用する {#use-hocs-for-cross-cutting-concerns}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We've since realized that mixins create more trouble than they are worth.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>&gt; **補足**
&gt;
&gt; 以前に横断的関心事を処理する方法としてミックスインをお勧めしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>[Read more](/blog/2016/07/13/mixins-considered-harmful.html) about why we've moved away from mixins and how you can transition your existing components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>私たちはその後にミックスインはそれが持つ価値以上の問題を引き起こすことに気づきました。ミックスインから離れる理由と、既存のコンポーネントを移行する方法については[こちらの詳細な記事を読んでください](/blog/2016/07/13/mixins-considered-harmful.html)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components are the primary unit of code reuse in React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>コンポーネントは React のコード再利用における基本単位です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, you'll find that some patterns aren't a straightforward fit for traditional components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>しかし、いくつかのパターンの中には、これまでのコンポーネントが素直に当てはまらないことがあることに気づいたかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, say you have a `CommentList` component that subscribes to an external data source to render a list of comments:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>例えば、コメントのリストを描画するのに外部のデータソースの購読を行う `CommentList` コンポーネントがあるとしましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Later, you write a component for subscribing to a single blog post, which follows a similar pattern:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>後になって、前述のパターンと似たような形で、1 件のブログ記事に関する情報を購読するコンポーネントを書くとしましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>`CommentList` and `BlogPost` aren't identical — they call different methods on `DataSource`, and they render different output.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>`CommentList` と `BlogPost` は同一ではありません。`DataSource` に対して異なるメソッドを呼び出し、異なる出力を描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But much of their implementation is the same:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>しかし、それらの実装の大部分は同じです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- On mount, add a change listener to `DataSource`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>- コンポーネントのマウント時に、`DataSource` にイベントリスナを登録する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- Inside the listener, call `setState` whenever the data source changes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>- リスナの内部で、`setState` をデータソースが変更されるたびに呼び出す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- On unmount, remove the change listener.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>- コンポーネントのアンマウント時には、イベントリスナを削除する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can imagine that in a large app, this same pattern of subscribing to `DataSource` and calling `setState` will occur over and over again.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>大規模なアプリケーションにおいては、`DataSource` を購読して `setState` を呼び出すという同様のパターンが何度も発生することが想像できるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We want an abstraction that allows us to define this logic in a single place and share it across many components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>1 つの場所にロジックを定義し、多数のコンポーネントを横断してロジックを共有可能にするような抽象化が欲しいところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is where higher-order components excel.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>このような場合には高階コンポーネントが有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can write a function that creates components, like `CommentList` and `BlogPost`, that subscribe to `DataSource`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>コンポーネントを作成するような関数を書いて、`DataSource` からデータを受け取る、`CommentList` や `BlogPost` のようなコンポーネントを作り出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function will accept as one of its arguments a child component that receives the subscribed data as a prop.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>その関数は引数の 1 つとして子コンポーネントを受け取り、その子コンポーネントは購読したデータを props の一部として受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's call the function `withSubscription`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>この関数を `withSubscription` と呼ぶことにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first parameter is the wrapped component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>1 つ目の引数はラップされるコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second parameter retrieves the data we're interested in, given a `DataSource` and the current props.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>2 つ目の引数は、与えられた `DataSource` と現在の props をもとに、関心のあるデータを取り出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When `CommentListWithSubscription` and `BlogPostWithSubscription` are rendered, `CommentList` and `BlogPost` will be passed a `data` prop with the most current data retrieved from `DataSource`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>`CommentListWithSubscription` と `BlogPostWithSubscription` が描画されると、`CommentList` と `BlogPost` は `DataSource` から取得した最新データを `data` プロパティとして受け取ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that a HOC doesn't modify the input component, nor does it use inheritance to copy its behavior.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC は入力のコンポーネントを改変したり、振る舞いをコピーするのに継承を利用したりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rather, a HOC *composes* the original component by *wrapping* it in a container component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>むしろ HOC は元のコンポーネントをコンテナコンポーネント内に*ラップする*ことで*組み合わせる*のです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A HOC is a pure function with zero side-effects.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC は副作用のない純関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And that's it!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>それだけです！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The wrapped component receives all the props of the container, along with a new prop, `data`, which it uses to render its output.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>ラップされたコンポーネントはコンテナの props のすべてに加えて新規のプロパティである `data` を受け取り、出力の描画に使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The HOC isn't concerned with how or why the data is used, and the wrapped component isn't concerned with where the data came from.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>外側にある HOC は渡すデータが使われる方法や理由には関心がありませんし、ラップされたコンポーネントの側はデータがどこからやって来たのかには関心を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because `withSubscription` is a normal function, you can add as many or as few arguments as you like.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>`withSubscription` は通常の関数なので、引数を好きなだけ増やしたり減らしたりできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you may want to make the name of the `data` prop configurable, to further isolate the HOC from the wrapped component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>例えば、`data` プロパティの名前を変更可能にして、HOC をラップされるコンポーネントから更に分離させることもできるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Or you could accept an argument that configures `shouldComponentUpdate`, or one that configures the data source.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>もしくは `shouldComponentUpdate` を設定する引数を受け取ったり、データソースを設定する引数を受け取りたいこともあるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These are all possible because the HOC has full control over how the component is defined.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC ではコンポーネントがどのように定義されるかを完全に管理できるため、上述のことは全て実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like components, the contract between `withSubscription` and the wrapped component is entirely props-based.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>コンポーネントのように、`withSubscription` とラップされるコンポーネントの間の契約は完全に props に基づいています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This makes it easy to swap one HOC for a different one, as long as they provide the same props to the wrapped component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>これにより同じ props をラップされるコンポーネントに与える限りは、ある HOC を他の HOC と簡単に交換できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This may be useful if you change data-fetching libraries, for example.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>このことは例えばデータ取得ライブラリを変更する場合に便利でしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Don't Mutate the Original Component. Use Composition. {#dont-mutate-the-original-component-use-composition}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>## 元のコンポーネントを変更するのではなく、コンポジションを使うこと {#dont-mutate-the-original-component-use-composition}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Resist the temptation to modify a component's prototype (or otherwise mutate it) inside a HOC.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC の中でコンポーネントのプロトタイプを変更したり、あるいは何にせよコンポーネントに変更を加えたりしたくなる誘惑に負けてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are a few problems with this.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>このコードにはいくつかの問題があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One is that the input component cannot be reused separately from the enhanced component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>1 つは入力のコンポーネントを改変されたコンポーネントとは別に再利用できなくなってしまうことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>More crucially, if you apply another HOC to `EnhancedComponent` that *also* mutates `componentDidUpdate`, the first HOC's functionality will be overridden!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>さらに悪いことに、もしこの `EnhancedComponent` に別の HOC を適用し、それが*同様に* `componentDidUpdate` に変更を加えるものであった場合、最初の HOC が加えた機能は上書きされてしまいます！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This HOC also won't work with function components, which do not have lifecycle methods.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>またこの HOC はライフサイクルメソッドを持たない関数コンポーネントには機能しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mutating HOCs are a leaky abstraction—the consumer must know how they are implemented in order to avoid conflicts with other HOCs.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>コンポーネントの改変を行うような HOC は不完全な抽象化です。つまり、利用する側は他の HOC との競合を避けるため、どのように実装されているかを知っておく必要があるのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of mutation, HOCs should use composition, by wrapping the input component in a container component:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>改変を行う代わりに、HOC はコンテナコンポーネントで入力されたコンポーネントをラップすることによるコンポジションを使用するべきです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This HOC has the same functionality as the mutating version while avoiding the potential for clashes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>この HOC は改変を行うバージョンと同等の機能を持ちつつ、衝突の可能性を回避しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It works equally well with class and function components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>クラス型と関数コンポーネントのどちらでも同様にうまく動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And because it's a pure function, it's composable with other HOCs, or even with itself.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>そして純関数なので、自分自身を含めた他の HOC と組み合わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may have noticed similarities between HOCs and a pattern called **container components**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>おそらく HOC と**コンテナコンポーネント**と呼ばれるパターンの類似性に気づいたでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Container components are part of a strategy of separating responsibility between high-level and low-level concerns.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>コンテナコンポーネントは高レベルと低レベルの関心事の責任を分離する戦略の一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>コンテナはデータ購読や state を管理してコンポーネントに props を渡し、渡された側のコンポーネントは UI の描画などの事柄を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>HOCs use containers as part of their implementation.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC はコンテナをその実装の一部として使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can think of HOCs as parameterized container component definitions.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC をパラメータ化されたコンテナコンポーネントの定義であると考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Convention: Pass Unrelated Props Through to the Wrapped Component {#convention-pass-unrelated-props-through-to-the-wrapped-component}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>## 規則：自身に関係のない props はラップされるコンポーネントにそのまま渡すこと {#convention-pass-unrelated-props-through-to-the-wrapped-component}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>HOCs add features to a component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC はコンポーネントに機能を追加するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They shouldn't drastically alter its contract.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>その props にもとづく契約は大きく変更すべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's expected that the component returned from a HOC has a similar interface to the wrapped component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC の返り値のコンポーネントはラップされたコンポーネントと似たようなインターフェースを持つことが期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>HOCs should pass through props that are unrelated to its specific concern.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC はその特定の関心とは関係のない props はラップされる関数に渡すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most HOCs contain a render method that looks something like this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>大抵の HOC はこのような描画メソッドを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This convention helps ensure that HOCs are as flexible and reusable as possible.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>この決まり事により、HOC が可能な限り柔軟で再利用しやすいものになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Convention: Maximizing Composability {#convention-maximizing-composability}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>## 規則：組み立てやすさを最大限保つこと {#convention-maximizing-composability}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Not all HOCs look the same.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>すべての HOC が同じ見た目になるわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sometimes they accept only a single argument, the wrapped component:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>引数としてラップされるコンポーネント 1 つだけを受け取ることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Usually, HOCs accept additional arguments.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>通常、HOC は追加の引数を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example from Relay, a config object is used to specify a component's data dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>この Relay からの例では、config オブジェクトがコンポーネントのデータ依存を指定するために使われています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most common signature for HOCs looks like this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>もっとも一般的な HOC の型シグネチャはこのようなものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>*What?!* If you break it apart, it's easier to see what's going on.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>*これは何なのでしょう?!* バラバラにしてみると、何が起こっているのかを理解しやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>```js
// connect is a function that returns another function
const enhance = connect(commentListSelector, commentListActions);
// The returned function is a HOC, which returns a component that is connected
// to the Redux store
const ConnectedComment = enhance(CommentList);
```
In other words, `connect` is a higher-order function that returns a higher-order component!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>```js
// connect is a function that returns another function
const enhance = connect(commentListSelector, commentListActions);
// The returned function is a HOC, which returns a component that is connected
// to the Redux store
const ConnectedComment = enhance(CommentList);
```言い換えれば、`connect` は高階コンポーネントを返す高階関数なのです！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This form may seem confusing or unnecessary, but it has a useful property.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>この形式は分かりにくかったり不要なものに思えるかもしれませんが、便利な性質を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Single-argument HOCs like the one returned by the `connect` function have the signature `Component =&gt; Component`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>`connect` 関数によって返されるもののような単一引数の HOC は、`Component =&gt; Component` という型シグネチャを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions whose output type is the same as its input type are really easy to compose together.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>入力の型と出力の型が同じ関数は一緒に組み合わせるのが大変簡単なのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(This same property also allows `connect` and other enhancer-style HOCs to be used as decorators, an experimental JavaScript proposal.)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>（この性質を使えば、`connect` や他の機能追加方式の HOC をデコレータ（提唱中の JavaScript の実験的機能）で使用することも可能になります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The `compose` utility function is provided by many third-party libraries including lodash (as [`lodash.flowRight`](https://lodash.com/docs/#flowRight)), [Redux](https://redux.js.org/api/compose), and [Ramda](https://ramdajs.com/docs/#compose).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>`compose` ユーティリティ関数は lodash（[`lodash.flowRight`](https://lodash.com/docs/#flowRight) として）、[Redux](https://redux.js.org/api/compose)、そして [Ramda](https://ramdajs.com/docs/#compose) といった多くのサードパーティ製ライブラリから提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Convention: Wrap the Display Name for Easy Debugging {#convention-wrap-the-display-name-for-easy-debugging}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>## 規則：デバッグしやすくするため表示名をラップすること {#convention-wrap-the-display-name-for-easy-debugging}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The container components created by HOCs show up in the [React Developer Tools](https://github.com/facebook/react/tree/main/packages/react-devtools) like any other component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC により作成されたコンテナコンポーネントは他のあらゆるコンポーネントと同様、[React Developer Tools](https://github.com/facebook/react/tree/master/packages/react-devtools) に表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To ease debugging, choose a display name that communicates that it's the result of a HOC.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>デバッグを容易にするため、HOC の結果だと分かるよう表示名を選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most common technique is to wrap the display name of the wrapped component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>最も一般的な手法は、ラップされるコンポーネントの表示名をラップすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>So if your higher-order component is named `withSubscription`, and the wrapped component's display name is `CommentList`, use the display name `WithSubscription(CommentList)`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>つまり高階コンポーネントが `withSubscription` と名付けられ、ラップされるコンポーネントの表示名が `CommentList` である場合、`WithSubscription(CommentList)` という表示名を使用しましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Caveats {#caveats}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>## 注意事項 {#caveats}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Higher-order components come with a few caveats that aren't immediately obvious if you're new to React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>高階コンポーネントには、あなたが React を始めて間もないならすぐには分からないような、いくつかの注意事項があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Don't Use HOCs Inside the render Method {#dont-use-hocs-inside-the-render-method}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>### render メソッド内部で HOC を使用しないこと {#dont-use-hocs-inside-the-render-method}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React's diffing algorithm (called [Reconciliation](/docs/reconciliation.html)) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>React の差分アルゴリズム（[Reconciliation](/docs/reconciliation.html) と呼ばれる）は、既存のサブツリーを更新すべきかそれを破棄して新しいものをマウントすべきかを決定する際に、コンポーネントの型が同一かどうかの情報を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the component returned from `render` is identical (`===`) to the component from the previous render, React recursively updates the subtree by diffing it with the new one.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>`render` メソッドから返されるコンポーネントが以前の描画から返されたコンポーネントと（`===`で検証して）同一だった場合、React はサブツリーを新しいツリーとの差分を取りながら再帰的に更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If they're not equal, the previous subtree is unmounted completely.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>コンポーネントが同一でなければ、以前のサブツリーは完全にアンマウントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Normally, you shouldn't need to think about this.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>通常このことを考慮する必要はありません。ですが HOC に関しては考えるべきことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But it matters for HOCs because it means you can't apply a HOC to a component within the render method of a component:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>このことが、render メソッド中でコンポーネントに HOC を適用してはいけないということを意味しているからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The problem here isn't just about performance — remounting a component causes the state of that component and all of its children to be lost.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>ここでの問題はパフォーマンスだけではありません。コンポーネントの再マウントによりコンポーネントとその子要素全ての state が失われるのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, apply HOCs outside the component definition so that the resulting component is created only once.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>こうするのではなく、結果としてのコンポーネントが 1 回だけつくられるようにするため、コンポーネント定義の外で HOC を適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Then, its identity will be consistent across renders.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>そうすれば、レンダー間でその同一性が保たれるようになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is usually what you want, anyway.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>何にせよ、通常の場合これが望ましい実装になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In those rare cases where you need to apply a HOC dynamically, you can also do it inside a component's lifecycle methods or its constructor.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC を動的に適用する必要があるような稀なケースでも、コンポーネントのライフサイクルメソッドやコンストラクタの中で行うようにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Static Methods Must Be Copied Over {#static-methods-must-be-copied-over}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>### 静的メソッドは必ずコピーすること {#static-methods-must-be-copied-over}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sometimes it's useful to define a static method on a React component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>React のコンポーネントで静的メソッドを定義することは便利であることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, Relay containers expose a static method `getFragment` to facilitate the composition of GraphQL fragments.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>例えば、Relay のコンテナは GraphQL fragment のコンポジションを容易に実現するため、`getFragment` という静的メソッドを公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you apply a HOC to a component, though, the original component is wrapped with a container component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>しかし、HOC をコンポーネントに適用すると、元のコンポーネントはコンテナコンポーネントにラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That means the new component does not have any of the static methods of the original component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>つまり新しいコンポーネントは元のコンポーネントの静的メソッドを 1 つも持っていないということになってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To solve this, you could copy the methods onto the container before returning it:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>この問題を解決するために、コンテナコンポーネントを返す前にメソッドをコピーすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this requires you to know exactly which methods need to be copied.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>しかし、この方法ではどのメソッドがコピーされる必要があるのか正確に知っておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use [hoist-non-react-statics](https://github.com/mridgway/hoist-non-react-statics) to automatically copy all non-React static methods:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>[hoist-non-react-statics](https://github.com/mridgway/hoist-non-react-statics) を使用することで、全ての非 React の静的メソッドを自動的にコピーできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another possible solution is to export the static method separately from the component itself.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>もう 1 つの解決策となりうる方法はコンポーネント自身とは分離して静的メソッドをエクスポートすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Refs Aren't Passed Through {#refs-arent-passed-through}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>### ref 属性は渡されない {#refs-arent-passed-through}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While the convention for higher-order components is to pass through all props to the wrapped component, this does not work for refs.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>高階コンポーネントの通例としては、すべての props はラップされたコンポーネントに渡されますが、ref に関してはそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That's because `ref` is not really a prop — like `key`, it's handled specially by React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>これは `ref` 属性が（`key` と同様）実際のプロパティではなく、React によって特別に処理されているものだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you add a ref to an element whose component is the result of a HOC, the ref refers to an instance of the outermost container component, not the wrapped component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>HOC から出力されたコンポーネントの要素に ref 属性を追加する場合、ref 属性はラップされた内側のコンポーネントではなく、最も外側のコンテナコンポーネントを参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The solution for this problem is to use the `React.forwardRef` API (introduced with React 16.3).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>この問題の解決方法は（React 16.3 で導入された）`React.forwardRef` API を使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>[Learn more about it in the forwarding refs section](/docs/forwarding-refs.html).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T053805Z">
        <seg>[詳しくは ref のフォワーディングの章をご覧ください](/docs/forwarding-refs.html)。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
