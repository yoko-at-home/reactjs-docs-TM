<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.3.2_0_6a661c5e0" segtype="sentence" srclang="EN-US"/>
  <body>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>---
id: thinking-in-react
title: Thinking in React
permalink: docs/thinking-in-react.html
redirect_from:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>---
id: thinking-in-react
title: React の流儀
permalink: docs/thinking-in-react.html
redirect_from:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React is, in our opinion, the premier way to build big, fast Web apps with JavaScript.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>巨大で軽快な Web アプリを開発する場合に、React は最高の手段であると、私たちは考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It has scaled very well for us at Facebook and Instagram.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>Facebook や Instagram といった私たちのサービスにおいても、とてもよくスケールしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One of the many great parts of React is how it makes you think about apps as you build them.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>React のすばらしい特長がいくつもありますが、あなたがどんなアプリを作ろうかと考えたことが、そのままアプリの作り方になる、というのはそのひとつです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this document, we'll walk you through the thought process of building a searchable product data table using React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>本ドキュメントでは、検索可能な商品データ表を React で作っていく様子をお見せしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Start With A Mock {#start-with-a-mock}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>## モックから始めよう {#start-with-a-mock}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Imagine that we already have a JSON API and a mock from our designer.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>すでに、JSON API が実装済みで、デザイナーからもデザインモックがもらえているとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The mock looks like this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>モックは次のような見た目だったとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>![Mockup](../images/blog/thinking-in-react-mock.png)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>![デザインモック](../images/blog/thinking-in-react-mock.png)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our JSON API returns some data that looks like this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>また、JSON API は次のようなデータを返してくるとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Step 1: Break The UI Into A Component Hierarchy {#step-1-break-the-ui-into-a-component-hierarchy}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>## Step 1: UI をコンポーネントの階層構造に落とし込む {#step-1-break-the-ui-into-a-component-hierarchy}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first thing you'll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>まず最初に行うのは、モックを形作っている各コンポーネント（構成要素）を四角で囲んで、それぞれに名前をつけていくことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're working with a designer, they may have already done this, so go talk to them!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>もしあなたがデザイナーと一緒に仕事をしている場合は、彼らがすでにこれに相当する作業を終えている可能性がありますので、話をしに行きましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Their Photoshop layer names may end up being the names of your React components!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>彼らが Photoshop でレイヤ名にしていた名前が、最終的にはあなたの React コンポーネントの名前になりうるのです！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But how do you know what should be its own component?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>しかし、どうやって単一のコンポーネントに括るべき範囲を見つけられるのでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the same techniques for deciding if you should create a new function or object.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>ちょうど、新しい関数やオブジェクトをいつ作るのかを決めるときと、同じ手法が使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One such technique is the [single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle), that is, a component should ideally only do one thing.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>このような手法のひとつに、[単一責任の原則 (single responsibility principle)](https://en.wikipedia.org/wiki/Single_responsibility_principle) があり、これはすなわち、ひとつのコンポーネントは理想的にはひとつのことだけをするべきだということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it ends up growing, it should be decomposed into smaller subcomponents.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>将来、コンポーネントが肥大化してしまった場合には、小さなコンポーネントに分割するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since you're often displaying a JSON data model to a user, you'll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>JSON のデータモデルをユーザに向けて表示することはよくありますので、モデルを正しく構築されていれば、UI（つまりコンポーネントの構造）にもうまくマッピングされるということが分かるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That's because UI and data models tend to adhere to the same *information architecture*.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>これは、UI とデータモデルが同じ **情報の構造** を持つ傾向があるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Separate your UI into components, where each component matches one piece of your data model.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>UI を分割して、それぞれのコンポーネントがデータモデルの厳密に一部分だけを表現するよう、落とし込みましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>![Component diagram](../images/blog/thinking-in-react-components.png)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>![コンポーネント図](../images/blog/thinking-in-react-components.png)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You'll see here that we have five components in our app.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>5 種類のコンポーネントがこのアプリの中にあることが見て取れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We've italicized the data each component represents.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>それぞれの解説の中で、データを表すものについては**太字**にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**`FilterableProductTable` (orange):** contains the entirety of the example</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>**`FilterableProductTable`（オレンジ色）：** このサンプル全体を含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**`SearchBar` (blue):** receives all *user input*</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>**`SearchBar`（青色）：** すべての*ユーザ入力*を受け付ける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**`ProductTable` (green):** displays and filters the *data collection* based on *user input*</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>**`ProductTable`（緑色）：** *ユーザ入力*に基づく*データの集合*を表示・フィルタする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**`ProductCategoryRow` (turquoise):** displays a heading for each *category*</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>**`ProductCategoryRow`（水色）：** *カテゴリ*を見出しとして表示する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**`ProductRow` (red):** displays a row for each *product*</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>**`ProductRow`（赤色）：** 各*商品*を 1 行で表示する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you look at `ProductTable`, you'll see that the table header (containing the "Name" and "Price" labels) isn't its own component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>`ProductTable` を見てみると、表のヘッダ（「Name」や「Price」のラベルを含む）が単独のコンポーネントになっていないことがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a matter of preference, and there's an argument to be made either way.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>これは好みの問題で、コンポーネントにするかしないかは両論あります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For this example, we left it as part of `ProductTable` because it is part of rendering the *data collection* which is `ProductTable`'s responsibility.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>今回の例でいえば、ヘッダを `ProductTable` の一部にしたのは、*データの集合*を描画するという `ProductTable` の責務の一環として適切だったからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if this header grows to be complex (e.g., if we were to add affordances for sorting), it would certainly make sense to make this its own `ProductTableHeader` component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>しかしながら、将来ヘッダーが肥大化して複雑になった場合（例えばソート機能を追加した場合など）は、`ProductTableHeader` のようなコンポーネントにするのが適切になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now that we've identified the components in our mock, let's arrange them into a hierarchy.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>さて、モック内にコンポーネントを特定できましたので、階層構造に並べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components that appear within another component in the mock should appear as a child in the hierarchy:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>モックで他のコンポーネントの中にあるコンポーネントを、階層構造でも子要素として配置すればいいのです。次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Step 2: Build A Static Version in React {#step-2-build-a-static-version-in-react}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>## Step 2: Reactで静的なバージョンを作成する {#step-2-build-a-static-version-in-react}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now that you have your component hierarchy, it's time to implement your app.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>さて、コンポーネントの階層構造が決まったので、アプリの実装に取り掛かりましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The easiest way is to build a version that takes your data model and renders the UI but has no interactivity.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>最初は、データモデルを受け取って UI の描画だけを行い、ユーザからの操作はできないというバージョンを作るのが、もっとも簡単でしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>表示の実装とユーザ操作の実装を切り離しておくことは重要です。静的な（操作できない）バージョンを作る際には、タイプ量が多い代わりに考えることが少なく、ユーザ操作を実装するときには、考えることが多い代わりにタイプ量は少ないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll see why.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>なぜそうなのかは後で説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To build a static version of your app that renders your data model, you'll want to build components that reuse other components and pass data using *props*.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>データモデルを描画するだけの機能を持った静的なバージョンのアプリを作る際には、他のコンポーネントを再利用しつつそれらに *props* を通じてデータを渡す形で、自分のコンポーネントを組み上げていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>*props* are a way of passing data from parent to child.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>*props* は親から子へとデータを渡すための手段です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're familiar with the concept of *state*, **don't use state at all** to build this static version.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>もし、あなたが *state* に慣れ親しんでいる場合でも、今回の静的なバージョンを作る上では**一切 state を使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>State is reserved only for interactivity, that is, data that changes over time.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>**state はユーザ操作や時間経過などで動的に変化するデータを扱うために確保されている機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since this is a static version of the app, you don't need it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>今回のアプリは静的なバージョンなので、state は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can build top-down or bottom-up.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>コンポーネントはトップダウンで作っても、ボトムアップで作っても問題ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, you can either start with building the components higher up in the hierarchy (i.e. starting with `FilterableProductTable`) or with the ones lower in it (`ProductRow`).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>つまり、高い階層にあるコンポーネント（例えば `FilterableProductTable`）から作り始めても、低い階層にあるコンポーネント（`ProductRow` など）から作り始めても、どちらでもいいのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In simpler examples, it's usually easier to go top-down, and on larger projects, it's easier to go bottom-up and write tests as you build.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>シンプルなアプリでは通常トップダウンで作った方が楽ですが、大きなプロジェクトでは開発をしながらテストを書き、ボトムアップで進める方がより簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At the end of this step, you'll have a library of reusable components that render your data model.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>ここまでのステップを終えると、データモデルを描画する再利用可能なコンポーネントのライブラリが手に入ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The components will only have `render()` methods since this is a static version of your app.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>このアプリは静的なバージョンなので、コンポーネントは `render()` メソッドだけを持つことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The component at the top of the hierarchy (`FilterableProductTable`) will take your data model as a prop.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>階層構造の中で最上位のコンポーネント（`FilterableProductTable`）が、データモデルを props として受け取ることになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you make a change to your underlying data model and call `ReactDOM.render()` again, the UI will be updated.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>元となるデータモデルを更新して再度 `ReactDOM.render()` を呼び出すと、UI が更新されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can see how your UI is updated and where to make changes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>このやり方なら、複雑なことをしていないので、UI がどのように更新されて、どこを変更すればよいか、理解できることでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React's **one-way data flow** (also called *one-way binding*) keeps everything modular and fast.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>React の**単方向データフロー**（あるいは*単方向バインディング*）により、すべてがモジュール化された高速な状態で保たれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Refer to the [React docs](/docs/) if you need help executing this step.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>このステップを実施する上で助けが必要な場合は、[React ドキュメント](/docs/)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### A Brief Interlude: Props vs State {#a-brief-interlude-props-vs-state}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>### 幕間：Props vs State {#a-brief-interlude-props-vs-state}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two types of "model" data in React: props and state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>React には 2 種類の「モデル」データが存在します。props と state です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's important to understand the distinction between the two;</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>このふたつの相違を理解するのは重要なことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>skim [the official React docs](/docs/state-and-lifecycle.html) if you aren't sure what the difference is.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>違いについて自信がない場合は、[公式の React ドキュメント](/docs/state-and-lifecycle.html)に目を通すとよいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also [FAQ: What is the difference between state and props?](/docs/faq-state.html#what-is-the-difference-between-state-and-props)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>[FAQ: state と props の違いは何ですか？](/docs/faq-state.html#what-is-the-difference-between-state-and-props) もご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Step 3: Identify The Minimal (but complete) Representation Of UI State {#step-3-identify-the-minimal-but-complete-representation-of-ui-state}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>## Step 3: UI 状態を表現する必要かつ十分な state を決定する {#step-3-identify-the-minimal-but-complete-representation-of-ui-state}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make your UI interactive, you need to be able to trigger changes to your underlying data model.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>UI をインタラクティブなものにするためには元となっているデータモデルを更新できる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React achieves this with **state**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>これは React なら **state** を使うことで実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To build your app correctly, you first need to think of the minimal set of mutable state that your app needs.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>適切に開発を進めていくにあたり、そのアプリに求められている更新可能な状態の最小構成を、最初に考えておいたほうがよいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key here is [DRY: *Don't Repeat Yourself*](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>ここで重要なのは、[DRY (don't repeat yourself)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)の原則です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>アプリケーションが必要としている最小限の状態を把握しておき、他に必要なものが出てきたら、そのとき計算すればよいのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you're building a TODO list, keep an array of the TODO items around; don't keep a separate state variable for the count.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>例えば、TODO リストを作る場合、TODO の各項目を配列で保持するだけにし、個数のカウント用に別の state 変数を持たないようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, when you want to render the TODO count, take the length of the TODO items array.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>その代わりに、TODO の項目数を表示したいのであれば、配列の length を使えばよいのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Think of all the pieces of data in our example application.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>今回のサンプルアプリを形作るすべてのデータについて考えてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We have:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>次のようなデータがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The original list of products</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* 元となる商品のリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The search text the user has entered</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* ユーザが入力した検索文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The value of the checkbox</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* チェックボックスの値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The filtered list of products</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* フィルタ済みの商品のリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's go through each one and figure out which one is state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>それぞれについて見ていき、どれが state になりうるのかを考えてみます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ask three questions about each piece of data:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>各データについて、3 つの質問をしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Is it passed in from a parent via props?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>親から props を通じて与えられたデータでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If so, it probably isn't state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>もしそうなら、それは state ではありません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Does it remain unchanged over time?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>時間経過で変化しないままでいるデータでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If so, it probably isn't state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>もしそうなら、それは state ではありません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Can you compute it based on any other state or props in your component?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>コンポーネント内にある他の props や state を使って算出可能なデータでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If so, it isn't state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>もしそうなら、それは state ではありません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The original list of products is passed in as props, so that's not state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>元となる商品のリストは props から渡されるので、これは state ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The search text and the checkbox seem to be state since they change over time and can't be computed from anything.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>検索文字列とチェックボックスは時間の経過の中で変化し、また、算出することもできないため、state だと思われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And finally, the filtered list of products isn't state because it can be computed by combining the original list of products with the search text and value of the checkbox.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>最後に、フィルタ済みの商品のリストは state ではありません。何故ならば、元となる商品のリストと検索文字列とチェックボックスの値を組み合わせることで、フィルタ済みの商品のリストを算出することが可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>So finally, our state is:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>というわけで、state と呼べるのは次の 2 つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The search text the user has entered</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* ユーザが入力した検索文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The value of the checkbox</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* チェックボックスの値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Step 4: Identify Where Your State Should Live {#step-4-identify-where-your-state-should-live}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>## Step 4: state をどこに配置するべきなのかを明確にする {#step-4-identify-where-your-state-should-live}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>OK, so we've identified what the minimal set of app state is.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>さて、state の最小構成が明確になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, we need to identify which component mutates, or *owns*, this state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>次は、どのコンポーネントが state を変化させるのか、つまり state を*所有*するのかを明確にしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remember: React is all about one-way data flow down the component hierarchy.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>復習：React は、コンポーネントの階層構造をデータが流れ落ちていく、単方向データフローで成り立っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It may not be immediately clear which component should own what state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>もしかすると、どのコンポーネントがどんな state を持つべきなのかが、すぐにはわからないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**This is often the most challenging part for newcomers to understand,** so follow these steps to figure it out:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>**これは、初学者が React への理解を深める上で、最も難しい問題になりがちなところ** なので、ステップを踏みながら理解していきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For each piece of state in your application:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>アプリの各 state について、次の各項目を確認していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Identify every component that renders something based on that state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* その state を使って表示を行う、すべてのコンポーネントを確認する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Find a common owner component (a single component above all the components that need the state in the hierarchy).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* 共通の親コンポーネントを見つける（その階層構造の中で、ある state を必要としているすべてのコンポーネントの上位にある単一のコンポーネントのことです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Either the common owner or another component higher up in the hierarchy should own the state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* 共通の親コンポーネントか、その階層構造でさらに上位の別のコンポーネントが state を持っているべきである</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* If you can't find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common owner component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* もし state を持つにふさわしいコンポーネントを見つけられなかった場合は、state を保持するためだけの新しいコンポーネントを作り、階層構造の中ですでに見つけておいた共通の親コンポーネントの上に配置する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's run through this strategy for our application:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>それでは、この戦術をサンプルアプリにも適用してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* `ProductTable` needs to filter the product list based on state and `SearchBar` needs to display the search text and checked state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* `ProductTable` は商品リストをフィルタする必要があり、`SearchBar` は検索文字列とチェック状態を表示する必要がある</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The common owner component is `FilterableProductTable`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* 共通の親コンポーネントは `FilterableProductTable` である</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* It conceptually makes sense for the filter text and checked value to live in `FilterableProductTable`</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>* 概念的にも、検索文字列とチェック状態が `FilterableProductTable` に配置されることは妥当であるいいですね。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Cool, so we've decided that our state lives in `FilterableProductTable`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>state を `FilterableProductTable` の中に配置することが決まりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, add an instance property `this.state = {filterText: '', inStockOnly: false}` to `FilterableProductTable`'s `constructor` to reflect the initial state of your application.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>では早速、インスタンス変数として `this.state = {filterText: '', inStockOnly: false}` を `FilterableProductTable` の `constructor` に追加して、初期状態をアプリに反映しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Then, pass `filterText` and `inStockOnly` to `ProductTable` and `SearchBar` as a prop.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>その次は、`filterText` と `inStockOnly` を `ProductTable` と `SearchBar` に props として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, use these props to filter the rows in `ProductTable` and set the values of the form fields in `SearchBar`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>最後に、これらの props を使って `ProductTable` のフィルタ処理を行い、`SearchBar` のフォームにも値を埋めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can start seeing how your application will behave: set `filterText` to `"ball"` and refresh your app.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>これで、このアプリがどんな振る舞いをするのか見られるようになってきました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You'll see that the data table is updated correctly.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>`filterText` に `"ball"` と入力した状態でアプリを更新すると、データの表が正しく更新されたことが確認できるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Step 5: Add Inverse Data Flow {#step-5-add-inverse-data-flow}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>## Step 5: 逆方向のデータフローを追加する {#step-5-add-inverse-data-flow}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>So far, we've built an app that renders correctly as a function of props and state flowing down the hierarchy.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>ここまでで、props と state が階層構造を流れ落ちていく関数として、正しく描画を行うアプリを作ることができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now it's time to support data flowing the other way: the form components deep in the hierarchy need to update the state in `FilterableProductTable`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>それでは、別の方向のデータフローもサポートしてみましょう。階層構造の奥深くにあるフォームのコンポーネントが、`FilterableProductTable` にある state を更新できるようにするのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React makes this data flow explicit to help you understand how your program works, but it does require a little more typing than traditional two-way data binding.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>React ではデータフローが明示的になりプログラムの動作が理解しやすくなりますが、従来の双方向データバインディングよりも少しタイプ量が増えてはしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to type or check the box in the current version of the example, you'll see that React ignores your input.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>試しに、現在のバージョンのサンプルで文字を打ち込んだり、チェックボックスを切り替えてみると、React がその入力を無視することがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is intentional, as we've set the `value` prop of the `input` to always be equal to the `state` passed in from `FilterableProductTable`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>これは意図的な挙動で、`input` の `value` props が、常に `FilterableProductTable` から渡された `state` と同じ値になるようにセットしてあるのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's think about what we want to happen.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>それでは、どんな挙動になってほしいのかを考えてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We want to make sure that whenever the user changes the form, we update the state to reflect the user input.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>ユーザがフォームを変更するたびに、ユーザ入力を反映するように state を更新したいですね。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since components should only update their own state, `FilterableProductTable` will pass callbacks to `SearchBar` that will fire whenever the state should be updated.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>コンポーネントの state を更新できるのは自分自身だけであるべきなので、`FilterableProductTable` は `SearchBar` にコールバックを渡しておいて、state を更新したいときに実行してもらうようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can use the `onChange` event on the inputs to be notified of it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>入力のたびに呼び出される `onChange` イベントを利用するとよいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The callbacks passed by `FilterableProductTable` will call `setState()`, and the app will be updated.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>このコールバックを実行された `FilterableProductTable` は、`setState()` を呼び出し、その結果としてアプリが更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## And That's It {#and-thats-it}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>## 終わりに {#and-thats-it}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hopefully, this gives you an idea of how to think about building components and applications with React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>これで React を使ってコンポーネントやアプリケーションを構築するときの考え方が身に付いたのではないでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While it may be a little more typing than you're used to, remember that code is read far more than it's written, and it's less difficult to read this modular, explicit code.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>それはもしかしたら、あなたのこれまでのやり方よりも、多くのコードを書くことになるかもしれません。しかしながら、コードは書くよりも読むことのほうが多いこと、そしてモジュール化されていて明示的であるコードはより読みやすいということを思い出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you start to build large libraries of components, you'll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T074339Z">
        <seg>大規模なコンポーネントのライブラリを構築し始めると、この明示性やモジュール化しやすさのありがたみが分かり始めます。そしてコードを再利用できるようになるにつれて、あなたが書くコードの行数は減っていくのです。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
