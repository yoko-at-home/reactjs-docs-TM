<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.3.2_0_6a661c5e0" segtype="sentence" srclang="EN-US"/>
  <body>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>---
id: concurrent-mode-suspense
title: Suspense for Data Fetching (Experimental)
permalink: docs/concurrent-mode-suspense.html
prev: concurrent-mode-intro.html
next: concurrent-mode-patterns.html
---</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>---
id: concurrent-mode-suspense
title: サスペンスを使ったデータ取得（実験的機能）
permalink: docs/concurrent-mode-suspense.html
prev: concurrent-mode-intro.html
next: concurrent-mode-patterns.html
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;Caution:
&gt;
&gt;This page was about experimental features that aren't yet available in a stable release. It was aimed at early adopters and people who are curious.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>&gt;警告:
&gt;
&gt; このページはアーリーアダプターや興味のある読者を対象に、安定リリースでまだ利用できない実験的機能を説明するために存在していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;
&gt;Much of the information on this page is now outdated and exists only for archival purposes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>&gt;
&gt; このページの説明のほとんどは既に古くなっており、アーカイブの目的のためだけに残しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**Please refer to the [React 18 Alpha announcement post](/blog/2021/06/08/the-plan-for-react-18.html
) for the up-to-date information.**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>最新の情報については [React 18 アルファのアナウンス](/blog/2021/06/08/the-plan-for-react-18.html)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;
&gt;Before React 18 is released, we will replace this page with stable documentation.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>&gt;
&gt; React 18 のリリースまでに、このページはより安定したドキュメントに置き換わる予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React 16.6 added a `&lt;Suspense&gt;` component that lets you "wait" for some code to load and declaratively specify a loading state (like a spinner) while we're waiting:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>React 16.6 で、コードのロードを「待機」して宣言的にロード中状態（スピナーのようなもの）を指定することができる `&lt;Suspense&gt;` コンポーネントが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense for Data Fetching is a new feature that lets you also use `&lt;Suspense&gt;` to **declaratively "wait" for anything else, including data.** This page focuses on the data fetching use case, but it can also wait for images, scripts, or other asynchronous work.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データ取得用のサスペンスは、**データも含むその他あらゆるものを宣言的に「待機」**するために `&lt;Suspense&gt;` を使えるようにする新機能です。このページではデータ取得のユースケースに焦点を当てて説明しますが、画像やスクリプト、あるいはその他の非同期的な作業の待機にも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [What Is Suspense, Exactly?](#what-is-suspense-exactly)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [そもそもサスペンスとは何なのか？](#what-is-suspense-exactly)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [What Suspense Is Not](#what-suspense-is-not)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [サスペンスは何でないのか](#what-suspense-is-not)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [What Suspense Lets You Do](#what-suspense-lets-you-do)
- [Using Suspense in Practice](#using-suspense-in-practice)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [サスペンスで何ができるのか](#what-suspense-lets-you-do)
- [現実環境でのサスペンスの使用](#using-suspense-in-practice)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [What If I Don’t Use Relay?](#what-if-i-dont-use-relay)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [Relay を使ってない場合は？](#what-if-i-dont-use-relay)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [For Library Authors](#for-library-authors)
- [Traditional Approaches vs Suspense](#traditional-approaches-vs-suspense)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [ライブラリ作者向け情報](#for-library-authors)
- [既存アプローチ vs サスペンス](#traditional-approaches-vs-suspense)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Approach 1: Fetch-on-Render (not using Suspense)](#approach-1-fetch-on-render-not-using-suspense)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [アプローチ 1: Fetch-on-Render（サスペンス不使用）](#approach-1-fetch-on-render-not-using-suspense)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Approach 2: Fetch-Then-Render (not using Suspense)](#approach-2-fetch-then-render-not-using-suspense)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [アプローチ 2: Fetch-Then-Render（サスペンス不使用）](#approach-2-fetch-then-render-not-using-suspense)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Approach 3: Render-as-You-Fetch (using Suspense)](#approach-3-render-as-you-fetch-using-suspense)
- [Start Fetching Early](#start-fetching-early)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [アプローチ 3: Render-as-You-Fetch（サスペンスを使用）](#approach-3-render-as-you-fetch-using-suspense)
- [早期から取得を開始する](#start-fetching-early)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [We’re Still Figuring This Out](#were-still-figuring-this-out)
- [Suspense and Race Conditions](#suspense-and-race-conditions)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [まだ仕様は検討中です](#were-still-figuring-this-out)
- [サスペンスと競合状態](#suspense-and-race-conditions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Race Conditions with useEffect](#race-conditions-with-useeffect)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [`useEffect` に伴う競合状態](#race-conditions-with-useeffect)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Race Conditions with componentDidUpdate](#race-conditions-with-componentdidupdate)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [`componentDidUpdate` に伴う競合状態](#race-conditions-with-componentdidupdate)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [The Problem](#the-problem)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [問題の本質](#the-problem)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Solving Race Conditions with Suspense](#solving-race-conditions-with-suspense)
- [Handling Errors](#handling-errors)
- [Next Steps](#next-steps)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>- [サスペンスで競合状態を解決する](#solving-race-conditions-with-suspense)
- [エラーの処理](#handling-errors)
- [次のステップ](#next-steps)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## What Is Suspense, Exactly?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>## そもそもサスペンスとは何なのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense lets your components "wait" for something before they can render.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスを使うことで、レンダー可能になる前にコンポーネントが何かを「待機」できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In [this example](https://codesandbox.io/s/frosty-hermann-bztrp), two components wait for an asynchronous API call to fetch some data:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>[この例](https://codesandbox.io/s/frosty-hermann-bztrp)では、2 つのコンポーネントが、あるデータを取得する非同期的な API の完了を待機します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/frosty-hermann-bztrp)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/frosty-hermann-bztrp)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This demo is a teaser.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このデモはチラ見せです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don't worry if it doesn't quite make sense yet.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>まだあまり意味が分からなくても心配は要りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll talk more about how it works below.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>以下でこれがどのように動作しているのかをお話しします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keep in mind that Suspense is more of a *mechanism*, and particular APIs like `fetchProfileData()` or `resource.posts.read()` in the above example are not very important.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスは*仕組み*であり、上記の例の `fetchProfileData()` や `resource.posts.read()` といった特定の API はあまり重要ではないということを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're curious, you can find their definitions right in the [demo sandbox](https://codesandbox.io/s/frosty-hermann-bztrp).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>興味があれば[デモ用サンドボックス](https://codesandbox.io/s/frosty-hermann-bztrp)に定義があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense is not a data fetching library.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスはデータ取得ライブラリではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's a **mechanism for data fetching libraries** to communicate to React that *the data a component is reading is not ready yet*.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスとは**データ取得ライブラリのための仕組み**であり、*コンポーネントが読み出そうとしているデータがまだ準備できていない*と React に伝えられるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React can then wait for it to be ready and update the UI.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これにより React はデータが準備できるまで待機してから UI を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At Facebook, we use Relay and its [new Suspense integration](https://relay.dev/docs/en/experimental/step-by-step).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>Facebook では、Relay と[新しい Suspense 連携機能](https://relay.dev/docs/en/experimental/step-by-step)を利用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We expect that other libraries like Apollo can provide similar integrations.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>Apollo のような他のライブラリも似たような連携機能が提供できることを期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the long term, we intend Suspense to become the primary way to read asynchronous data from components -- no matter where that data is coming from.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>長期的にはサスペンスが、コンポーネントで非同期的なデータ（それがどこから来るのかに関わらず）を読み込む際の主要な方法となることを意図しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### What Suspense Is Not {#what-suspense-is-not}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### サスペンスは何でないのか {#what-suspense-is-not}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense is significantly different from existing approaches to these problems, so reading about it for the first time often leads to misconceptions.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスはこの種の問題に対する既存のアプローチとは大きく異なっているため、初めて読んだときに誤解してしまうことがよくあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's clarify the most common ones:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>最もよくある誤解を解いておきましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **It is not a data fetching implementation.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* **データ取得の実装ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>** It does not assume that you use GraphQL, REST, or any other particular data format, library, transport, or protocol.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**あなたが GraphQL、REST、その他どのような具体的なデータフォーマット、ライブラリ、転送経路、プロトコルを使っているのかについて仮定を置きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **It is not a ready-to-use client.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* **すぐに使えるクライアントではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>** You can't "replace" `fetch` or Relay with Suspense.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**`fetch` や Relay をサスペンスで「置き換える」ことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But you can use a library that's integrated with Suspense (for example, [new Relay APIs](https://relay.dev/docs/en/experimental/api-reference)).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>しかしサスペンスと統合されたライブラリを使うことはできます（例えば [Relay の新 API](https://relay.dev/docs/en/experimental/api-reference)）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **It does not couple data fetching to the view layer.** It helps orchestrate displaying the loading states in your UI, but it doesn't tie your network logic to React components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* **データ取得をビューレイヤと密結合させません。**ロード中状態をあなたの UI でうまく表示するための補助とはなりますが、React コンポーネントをネットワーク関係のロジックと結合させることはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### What Suspense Lets You Do {#what-suspense-lets-you-do}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### サスペンスで何ができるのか {#what-suspense-lets-you-do}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>So what's the point of Suspense?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ではサスペンスとは要するに何なのでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are a few ways we can answer this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これに対する答え方はいくつかあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **It lets data fetching libraries deeply integrate with React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* **データ取得ライブラリが React と深く連携できるようにするためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>** If a data fetching library implements Suspense support, using it from React components feels very natural.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**データ取得ライブラリがサスペンスをサポートすることで、React コンポーネントからそれを非常に自然に扱えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **It lets you orchestrate intentionally designed loading states.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* **ロード中状態の表示を注意深く設計することが容易になります**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>** It doesn't say _how_ the data is fetched, but it lets you closely control the visual loading sequence of your app.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスは*どのように*データが取得されるのかについて関知しませんが、アプリケーションのローディングシーケンスを細かく制御することができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **It helps you avoid race conditions.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* **競合状態 (race condition) を避ける手助けになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>** Even with `await`, asynchronous code is often error-prone.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**`await` を使っていてすら、非同期のコードはエラーを起こしがちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense feels more like reading data *synchronously* — as if it were already loaded.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスを使うことで、データが*同期的に*読み出されているかのように、まるで既にロード済みであるかのように感じられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Using Suspense in Practice {#using-suspense-in-practice}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>## 現実環境でのサスペンスの使用 {#using-suspense-in-practice}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At Facebook, so far we have only used the Relay integration with Suspense in production.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>Facebook では今のところ、本番環境において Relay のサスペンス連携機能のみを利用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**If you're looking for a practical guide to get started today, [check out the Relay Guide](https://relay.dev/docs/en/experimental/step-by-step)!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**今すぐ始めるための実用的なガイドが見たい場合は、[Relay のガイドをご覧ください](https://relay.dev/docs/en/experimental/step-by-step)！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>** It demonstrates patterns that have already worked well for us in production.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>** 本番環境で既にうまく動作しているパターンについて述べられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**The code demos on this page use a "fake" API implementation rather than Relay.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**このページのコードデモでは Relay ではなくフェイクの API 実装を使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>** This makes them easier to understand if you're not familiar with GraphQL, but they won't tell you the "right way" to build an app with Suspense.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**このため GraphQL に馴染みがない場合でも理解しやすくなっていますが、サスペンスを使ってアプリケーションを構築するための「正しいやり方」については述べていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This page is more conceptual and is intended to help you see *why* Suspense works in a certain way, and which problems it solves.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このページは概念的なものであり、サスペンスが*なぜ*このように動作し、どんな問題を解決するのかについて理解できるようにすることを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### What If I Don't Use Relay?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### Relay を使ってない場合は？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don't use Relay today, you might have to wait before you can really try Suspense in your app.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>今 Relay を使っていないのなら、サスペンスをあなたのアプリケーションで使うのは待った方がいいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>So far, it's the only implementation that we tested in production and are confident in.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>現在のところ、Relay が本番環境でテストされ、我々が自信を持っている唯一の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Over the next several months, many libraries will appear with different takes on Suspense APIs.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この先の数か月で、サスペンスの API を様々な方法で利用した多くのライブラリが登場することでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**If you prefer to learn when things are more stable, you might prefer to ignore this work for now, and come back when the Suspense ecosystem is more mature.**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**もっと安定したものを学びたいという人は、我々の作業を今のところは無視して、サスペンス周りのエコシステムが成熟してから戻ってくるのが良いかもしれません。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also write your own integration for a data fetching library, if you'd like.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>望むのであれば、データ取得ライブラリに対するあなた独自の連携機能を書くことは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### For Library Authors {#for-library-authors}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### ライブラリ作者向け情報 {#for-library-authors}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We expect to see a lot of experimentation in the community with other libraries.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これからコミュニティ内で他のライブラリを使った多くの実験がなされると思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is one important thing to note for data fetching library authors.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ライブラリ作者が覚えておいて欲しい重要なことが 1 つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although it's technically doable, Suspense is **not** currently intended as a way to start fetching data when a component renders.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>技術的には可能ですが、サスペンスはコンポーネントがレンダーされてからデータ取得を開始するための方法であることを意図して*いません*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rather, it lets components express that they're "waiting" for data that is *already being fetched*.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>そうではなく、*既に取得されつつある*データに対して、コンポーネントがそれを「待機」中であると宣言できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Building Great User Experiences with Concurrent Mode and Suspense](/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html) describes why this matters and how to implement this pattern in practice.**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[Building Great User Experiences with Concurrent Mode and Suspense](/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html) で、なぜこのことが重要で、実際にどう実装すればよいのかについて説明しています。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless you have a solution that helps prevent waterfalls, we suggest to prefer APIs that favor or enforce fetching before render.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ウォーターフォール (waterfall) の問題を回避できるソリューションをお持ちなのでない限り、レンダー前にデータ取得を行うことを推奨する、あるいは強制するような API が望ましいと考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a concrete example, you can look at how [Relay Suspense API](https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery) enforces preloading.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>具体例として、[Relay Suspense API](https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery) がどのようにプリロードを強制するのかについて見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our messaging about this hasn't been very consistent in the past.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ここでの我々のメッセージは、過去にはあまり一貫したものではありませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense for Data Fetching is still experimental, so you can expect our recommendations to change over time as we learn more from production usage and understand the problem space better.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスによるデータ取得はまだ実験的なものであり、我々が本番環境での使用のされ方について学び、この問題領域についてより理解するに従って、我々の推奨も変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Traditional Approaches vs Suspense {#traditional-approaches-vs-suspense}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>## 既存アプローチ vs サスペンス {#traditional-approaches-vs-suspense}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We could introduce Suspense without mentioning the popular data fetching approaches.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>すでに人気のあるデータ取得のアプローチについて言及せずにサスペンスを紹介することもできたでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this makes it more difficult to see which problems Suspense solves, why these problems are worth solving, and how Suspense is different from the existing solutions.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>しかしそれでは、サスペンスがどのような問題を解決するのか、なぜそれが解決すべき問題なのか、これまでの方法とどう違うのか、といったことが分かりづらくなってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, we'll look at Suspense as a logical next step in a sequence of approaches:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>代わりに、サスペンスのことを、これまでのアプローチの理論的な後継ステップとして見ていくことにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **Fetch-on-render (for example, `fetch` in `useEffect`):** Start rendering components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* **Fetch-on-render（例：`useEffect` 内で `fetch`）：**コンポーネントのレンダーを開始する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each of these components may trigger data fetching in their effects and lifecycle methods.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これらのコンポーネントがそれぞれ副作用やライフサイクルメソッド内でデータの取得をトリガする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This approach often leads to "waterfalls".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このアプローチはしばしば "ウォーターフォール" の問題を引き起こす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **Fetch-then-render (for example, Relay without Suspense):** Start fetching all the data for the next screen as early as possible.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* **Fetch-then-render（例：サスペンスなしの Relay）：**次の画面のためのデータの取得をできるだけ早く開始する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the data is ready, render the new screen.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データの準備が整ったら、新しい画面をレンダーする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can't do anything until the data arrives.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データが到着するまで何も行えない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **Render-as-you-fetch (for example, Relay with Suspense):** Start fetching all the required data for the next screen as early as possible, and start rendering the new screen *immediately — before we get a network response*.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* **Render-as-you-fetch（例：サスペンスを使った Relay）：**次の画面のためのデータの取得をできるだけ早く開始し、そして**直後に、つまりネットワークのレスポンスが得られる前に**新しい画面のレンダーを開始する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As data streams in, React retries rendering components that still need data until they're all ready.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データが順に到着するにつれて、React はデータが必要なコンポーネントのレンダーを繰り返し、最終的にすべてが描画済みとなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;Note
&gt;
&gt;This is a bit simplified, and in practice solutions tend to use a mix of different approaches.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>&gt;補足：
&gt;
&gt;これはやや簡略化された説明であり、現実のソリューションでは複数のアプローチが混在する傾向にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Still, we will look at them in isolation to better contrast their tradeoffs.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>それでも、それぞれのトレードオフを対比するためにこれらを別々に考えることにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To compare these approaches, we'll implement a profile page with each of them.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これらのアプローチを比較するためにそれぞれの手法でプロフィールページを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Approach 1: Fetch-on-Render (not using Suspense) {#approach-1-fetch-on-render-not-using-suspense}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### アプローチ 1: Fetch-on-Render（サスペンス不使用）{#approach-1-fetch-on-render-not-using-suspense}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A common way to fetch data in React apps today is to use an effect:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>現在の React アプリケーションでデータを取得する一般的な方法は副作用 (effect) を使用することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We call this approach "fetch-on-render" because it doesn't start fetching until *after* the component has rendered on the screen.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>画面上にコンポーネントがレンダーされた**後**までデータ取得が始まらないので、このアプローチのことを "fetch-on-render" と呼ぶことにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This leads to a problem known as a "waterfall".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これは "ウォーターフォール" と呼ばれる問題を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Consider these `&lt;ProfilePage&gt;` and `&lt;ProfileTimeline&gt;` components:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>以下の `&lt;ProfilePage&gt;` と `&lt;ProfileTimeline&gt;` のコンポーネントを考えてみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/fragrant-glade-8huj6)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/fragrant-glade-8huj6)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you run this code and watch the console logs, you'll notice the sequence is:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このコードを実行してコンソールのログで眺めると、実行の順番は以下のようになっています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We start fetching user details
2.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ユーザ詳細情報の取得を開始
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We wait...
3.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>待機する…
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We finish fetching user details
4.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ユーザ詳細情報の取得が完了
4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We start fetching posts
5.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>タイムライン投稿 (posts) の取得を開始
5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We wait...
6.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>待機する…
6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We finish fetching posts</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>投稿の取得が完了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If fetching user details takes three seconds, we'll only *start* fetching the posts after three seconds!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ユーザ詳細情報の取得に 3 秒かかる場合、投稿の取得の*開始*が 3 秒後になってしまいます！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That's a "waterfall": an unintentional *sequence* that should have been parallelized.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これが「ウォーターフォール」、つまり並列化可能にもかかわらず意図せず混入してしまった*シーケンス*です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Waterfalls are common in code that fetches data on render.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>レンダー時にデータを取得するコードではウォーターフォールはよく発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They're possible to solve, but as the product grows, many people prefer to use a solution that guards against this problem.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>修正することは可能ですが、プロダクトが成長するにつれて多くの人はこの問題を解決しづらくするような手法を使うようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Approach 2: Fetch-Then-Render (not using Suspense) {#approach-2-fetch-then-render-not-using-suspense}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### アプローチ 2: Fetch-Then-Render（サスペンス不使用）{#approach-2-fetch-then-render-not-using-suspense}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Libraries can prevent waterfalls by offering a more centralized way to do data fetching.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ライブラリは、より中央集権的なデータ取得の方法を提供することで、ウォーターフォールを防止することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, Relay solves this problem by moving the information about the data a component needs to statically analyzable *fragments*, which later get composed into a single query.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>例えば、Relay はコンポーネントが必要とするデータを静的に解析可能な*フラグメント*に移動し、あとでそれを単一のクエリに組み合わせる、という方法でこの問題を解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On this page, we don't assume knowledge of Relay, so we won't be using it for this example.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このページでは Relay の知識があることを前提としていませんので、この例では使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, we'll write something similar manually by combining our data fetching methods:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>代わりに、2 つのデータ取得メソッドを組み合わせて似たようなものを手書きします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, `&lt;ProfilePage&gt;` waits for both requests but starts them in parallel:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この例では `&lt;ProfilePage&gt;` は両方のリクエストを待機しますが、それらを同時に開始しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/wandering-morning-ev6r0)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/wandering-morning-ev6r0)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The event sequence now becomes like this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これで、イベントの流れは以下のようなものになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We start fetching user details
2.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ユーザ詳細情報の取得を開始
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We start fetching posts
3.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>タイムライン投稿の取得を開始
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We wait...
4.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>待機する…
4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We finish fetching user details
5.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ユーザ詳細情報の取得が完了
5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We finish fetching posts</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>投稿の取得が完了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We've solved the previous network "waterfall", but accidentally introduced a different one.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これにより前述のネットワークの "ウォーターフォール" が解決されましたが、うっかり別のウォーターフォールができてしまいました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We wait for *all* data to come back with `Promise.all()` inside `fetchProfileData`, so now we can't render profile details until the posts have been fetched too.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>`fetchProfileData` の内部で `Promise.all()` を使って*すべて*のデータが到着するまで待機しているので、投稿がロードされるまでプロフィール詳細画面をレンダーすることができないのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We have to wait for both.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>両方を待つ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Of course, this is possible to fix in this particular example.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この特定の例に関して言えば、もちろん修正は可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We could remove the `Promise.all()` call, and wait for both Promises separately.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>`Promise.all()` を除去して両方の Promise を個別に待つようにすればいいのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this approach gets progressively more difficult as the complexity of our data and component tree grows.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>しかし、データやコンポーネントツリーの複雑性が増すにつれて、このような手法はだんだんと困難になっていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's hard to write reliable components when arbitrary parts of the data tree may be missing or stale.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データツリーのどこかが欠けていたり古くなっていたりしている場合、信頼できるコンポーネントを書くのは困難です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>So fetching all data for the new screen and *then* rendering is often a more practical option.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>なので新しい画面に必要なデータが全部到着した*後で*レンダーをする、というのがしばしば現実的な選択肢になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Approach 3: Render-as-You-Fetch (using Suspense) {#approach-3-render-as-you-fetch-using-suspense}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### アプローチ 3: Render-as-You-Fetch（サスペンスを使用）{#approach-3-render-as-you-fetch-using-suspense}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the previous approach, we fetched data before we called `setState`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これまでのアプローチでは、`setState` を呼び出す前にデータを取得していました：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Start fetching
2.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データ取得を開始
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finish fetching
3.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データ取得が完了
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Start rendering</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>レンダーを開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With Suspense, we still start fetching first, but we flip the last two steps around:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスを使うと、データ取得をまず開始しますが、最後の 2 つのステップが入れ替わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Start fetching
2.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データ取得を開始
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**Start rendering**
3.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**レンダーを開始**
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**Finish fetching**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**データ取得が完了**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**With Suspense, we don't wait for the response to come back before we start rendering.** In fact, we start rendering *pretty much immediately* after kicking off the network request:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**サスペンスを使うと、レンダーを始める前にレスポンスが返ってくるのを待つ必要がなくなります。**むしろ、ネットワークリクエストを叩いた*その直後*にレンダーを開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/frosty-hermann-bztrp)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/frosty-hermann-bztrp)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's what happens when we render `&lt;ProfilePage&gt;` on the screen:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>画面の `&lt;ProfilePage&gt;` をレンダーしたときに起こるのは以下のようなことです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We've already kicked off the requests in `fetchProfileData()`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>レンダー時点で `fetchProfileData()` を使ってリクエストがスタートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It gave us a special "resource" instead of a Promise.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この関数は Promise ではなく特殊な "リソース (resource)" を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a realistic example, it would be provided by our data library's Suspense integration, like Relay.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>現実的な例では、Relay のようなデータ取得ライブラリのサスペンス連携機能を使うことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React tries to render `&lt;ProfilePage&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>React は `&lt;ProfilePage&gt;` のレンダーを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It returns `&lt;ProfileDetails&gt;` and `&lt;ProfileTimeline&gt;` as children.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>子要素として `&lt;ProfileDetails&gt;` と `&lt;ProfileTimeline&gt;` が返ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React tries to render `&lt;ProfileDetails&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>React は `&lt;ProfileDetails&gt;` のレンダーを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It calls `resource.user.read()`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>内部で `resource.user.read()` が呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>None of the data is fetched yet, so this component "suspends".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データはまだ何も取得されていないので、このコンポーネントは "サスペンド (suspend)" します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React skips over it, and tries rendering other components in the tree.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>React はこのコンポーネントを飛ばして、ツリーの他のコンポーネントのレンダーを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React tries to render `&lt;ProfileTimeline&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>React は `&lt;ProfileTimeline&gt;` のレンダーを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It calls `resource.posts.read()`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>内部で `resource.posts.read()` が呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Again, there's no data yet, so this component also "suspends".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>今回も、まだデータがありませんので、このコンポーネントは "サスペンド" します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React skips over it too, and tries rendering other components in the tree.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>React はこのコンポーネントも飛ばして、ツリーの他のコンポーネントのレンダーを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's nothing left to try rendering.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>レンダーを試みるべき他のコンポーネントは残っていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because `&lt;ProfileDetails&gt;` suspended, React shows the closest `&lt;Suspense&gt;` fallback above it in the tree: `<bpt i="1" x="1">&lt;h1&gt;</bpt>Loading profile...<ept i="1">&lt;/h1&gt;</ept>`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>`&lt;ProfileDetails&gt;` がサスペンドしたので、React はツリーの直上にある `&lt;Suspense&gt;` フォールバックを表示します：`<bpt i="1" x="1">&lt;h1&gt;</bpt>Loading profile...<ept i="1">&lt;/h1&gt;</ept>`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We're done for now.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ひとまずこれで終わりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This `resource` object represents the data that isn't there yet, but might eventually get loaded.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この `resource` オブジェクトが、まだ存在していないがいずれロードされるであろうデータを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we call `read()`, we either get the data, or the component "suspends".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>`read()` を呼び出すと、データが手に入るか、あるいはコンポーネントが "サスペンド" します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**As more data streams in, React will retry rendering, and each time it might be able to progress "deeper".** When `resource.user` is fetched, the `&lt;ProfileDetails&gt;` component will render successfully and we'll no longer need the `<bpt i="1" x="1">&lt;h1&gt;</bpt>Loading profile...<ept i="1">&lt;/h1&gt;</ept>` fallback.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**より多くのデータが到着するごとに React は再レンダーを試み、その度により「深い」ところまで進めるようになる可能性があります**。`resource.user` が取得できたら、`&lt;ProfileDetails&gt;` コンポーネントがレンダーされ、`<bpt i="1" x="1">&lt;h1&gt;</bpt>Loading profile...<ept i="1">&lt;/h1&gt;</ept>` のフォールバックが不要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Eventually, we'll get all the data, and there will be no fallbacks on the screen.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>最終的に、すべてのデータが到着したら、画面上からフォールバックが消えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This has an interesting implication.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これは興味深い事実を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even if we use a GraphQL client that collects all data requirements in a single request, *streaming the response lets us show more content sooner*.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>単一のリクエストで必要なすべてのデータを集めてくる GraphQL クライアントを使っていたとしても、*リソースのストリーミングのお陰で、より多くのコンテンツを早期から表示できるようになる*のです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because we render-*as-we-fetch* (as opposed to *after* fetching), if `user` appears in the response earlier than `posts`, we'll be able to "unlock" the outer `&lt;Suspense&gt;` boundary before the response even finishes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データ取得の*後*ではなくデータ取得を*行いながら*レンダーするので、レスポンス中で `user` が `posts` より先に現れたなら、レスポンスが終了する前に外側の `&lt;Suspense&gt;` バウンダリを "アンロック" 可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We might have missed this earlier, but even the fetch-then-render solution contained a waterfall: between fetching and rendering.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>見逃していたかもしれないので繰り返しますが、fetch-then-render のソリューションにも、データ取得とレンダーとの間でウォーターフォールが存在していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense doesn't inherently suffer from this waterfall, and libraries like Relay take advantage of this.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスにはこのウォーターフォールの問題がなく、Relay のようなライブラリはこのことをうまく利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note how we eliminated the `if (...)` "is loading" checks from our components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これにより `if (...)` による「ロード中か」のチェックが消えたことにも注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This doesn't only remove boilerplate code, but it also simplifies making quick design changes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これによりボイラープレートを減らせるだけでなく、素早い設計の変更が簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if we wanted profile details and posts to always "pop in" together, we could delete the `&lt;Suspense&gt;` boundary between them.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>例えば、プロフィール詳細とタイムライン投稿が同時に「ぱっと」出現するようにしたくなったなら、その 2 つの間にある `&lt;Suspense&gt;` を取り除けばいいのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Or we could make them independent from each other by giving each *its own* `&lt;Suspense&gt;` boundary.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>あるいはそれぞれに*個別の* `&lt;Suspense&gt;` バウンダリを与えることでそれぞれを独立させることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense lets us change the granularity of our loading states and orchestrate their sequencing without invasive changes to our code.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスにより、コードに大きく手を加えることなしに、ロード中状態の粒度を変更し順番を制御できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Start Fetching Early {#start-fetching-early}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>## 早期から取得を開始する {#start-fetching-early}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're working on a data fetching library, there's a crucial aspect of Render-as-You-Fetch you don't want to miss.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データ取得ライブラリを作成中なのであれば、Render-as-You-Fetch に関して忘れてはならない重要な特徴があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**We kick off fetching _before_ rendering.** Look at this code example closer:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**レンダーより*前に*取得を開始する**ということです。コード例で詳しく見てみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/frosty-hermann-bztrp)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/frosty-hermann-bztrp)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the `read()` call in this example doesn't *start* fetching.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この例の `read()` 呼び出しが取得を*開始*しているのではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It only tries to read the data that is **already being fetched**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**既に取得の最中である**データの読み出しを試みているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This difference is crucial to creating fast applications with Suspense.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスを使って高速なアプリケーションを作成するにあたってこの違いは非常に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We don't want to delay loading data until a component starts rendering.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>コンポーネントのレンダーが始まるまでデータのロードを遅らせたくないのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a data fetching library author, you can enforce this by making it impossible to get a `resource` object without also starting a fetch.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>データ取得ライブラリ作者は、実際のデータフェッチを始めないと `resource` オブジェクトが取得できないようにすることで、これを強制できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every demo on this page using our "fake API" enforces this.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このページの「フェイク API」を使ったすべてのデモは、これを強制しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You might object that fetching "at the top level" like in this example is impractical.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この例のように「トップレベルで」データを取得するのは非現実的だと思われるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>What are we going to do if we navigate to another profile's page?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>別のプロフィールページに移動したくなったらどうするのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We might want to fetch based on props.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>props の値に応じてデータ取得をしたいのかもしれませんよね。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The answer to this is **we want to start fetching in the event handlers instead**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>答えは、**イベントハンドラでデータ取得を開始する**ことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here is a simplified example of navigating between user's pages:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ユーザページ間を移動するシンプルな例です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/infallible-feather-xjtbu)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/infallible-feather-xjtbu)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With this approach, we can **fetch code and data in parallel**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このアプローチにより、**コードとデータを並行して取得**できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we navigate between pages, we don't need to wait for a page's code to load to start loading its data.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ページ間でナビゲートする場合、ページのデータのロードを開始するためにそのページのコードがロードされるのを待つ必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can start fetching both code and data at the same time (during the link click), delivering a much better user experience.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>（リンクのクリック時に）コードとデータの両方の取得を開始すればよく、それでユーザ体験はずっと向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This poses a question of how do we know *what* to fetch before rendering the next screen.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>次に湧いてくる疑問は、次の画面をレンダーしていないのに**何を**取得するのかをどうやって知るのか、です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are several ways to solve this (for example, by integrating data fetching closer with your routing solution).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これを解決するいくつかの方法があります（例えばデータ取得をルーティングソリューションの近くに統合する、など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you work on a data fetching library, [Building Great User Experiences with Concurrent Mode and Suspense](/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html) presents a deep dive on how to accomplish this and why it's important.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>あなたがデータ取得ライブラリの開発をしている場合は、[Building Great User Experiences with Concurrent Mode and Suspense](/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html) で、どのようにこれを実現し、なぜこれが重要なのかについて説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### We're Still Figuring This Out {#were-still-figuring-this-out}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### まだ仕様は検討中です {#were-still-figuring-this-out}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense itself as a mechanism is flexible and doesn't have many constraints.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>仕組みとしてのサスペンスは柔軟なものであり、制約は多くありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Product code needs to be more constrained to ensure no waterfalls, but there are different ways to provide these guarantees.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>本番のコードではウォーターフォールがないことを保証するためにもっと制約が必要ですが、そのような保証を与えるための方法は様々です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some questions that we're currently exploring include:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>我々が検討中の疑問は以下のようなものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Fetching early can be cumbersome to express.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* データ取得の早期開始を明示するのが難しいことがある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How do we make it easier to avoid waterfalls?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>ウォーターフォールを避けるため、そこを簡単にできるか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* When we fetch data for a page, can the API encourage including data for instant transitions *from* it?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* あるページのデータを取得する時に、そのページ*から*即座に遷移できるためのデータを含めるよう API が仕向けるべきか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* What is the lifetime of a response?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* レスポンスのライフタイムは？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Should caching be global or local?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>キャッシュはグローバル、あるいはローカルであるべきか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Who manages the cache?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>キャッシュをだれが管理するのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Can Proxies help express lazy-loaded APIs without inserting `read()` calls everywhere?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* Proxy を使うことで、あちこちに `read()` を挿入せずとも遅延ロード API を表現することが可能か？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* What would the equivalent of composing GraphQL queries look like for arbitrary Suspense data?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* 任意のサスペンスデータに対して、GraphQL クエリの構築に相当するものはどのような見た目になるか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Relay has its own answers to some of these questions.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これらの疑問のいくつかについて Relay は独自の回答を有しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is certainly more than a single way to do it, and we're excited to see what new ideas the React community comes up with.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>やり方は間違いなく複数あり、React コミュニティがどのようなものを新しく思いつくのか、楽しみにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Suspense and Race Conditions {#suspense-and-race-conditions}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>## サスペンスと競合状態 {#suspense-and-race-conditions}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Race conditions are bugs that happen due to incorrect assumptions about the order in which our code may run.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>競合状態 (race condition) は、コードが実行される順番について誤った前提を置くために発生するバグです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fetching data in the `useEffect` Hook or in class lifecycle methods like `componentDidUpdate` often leads to them.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>`useEffect` フックやクラスの `componentDidUpdate` のようなライフサイクルメソッドを使ってデータ取得を行うと、しばしばこれが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense can help here, too — let's see how.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスはここでも有用です。どのように有用なのか見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To demonstrate the issue, we will add a top-level `&lt;App&gt;` component that renders our `&lt;ProfilePage&gt;` with a button that lets us **switch between different profiles**:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>問題の説明のために、トップレベルの `&lt;App&gt;` コンポーネントを追加して、`&lt;ProfilePage&gt;` をレンダーさせるとともに、**複数のプロフィールを切り替える**ことのできるボタンを配置しましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's compare how different data fetching strategies deal with this requirement.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この要求に対して複数のデータ取得法がどのようにするのかを比較してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Race Conditions with `useEffect` {#race-conditions-with-useeffect}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### `useEffect` に伴う競合状態 {#race-conditions-with-useeffect}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, we'll try a version of our original "fetch in effect" example.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>まずは元の「副作用内でデータ取得」の例を書き換えて試してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll modify it to pass an `id` parameter from the `&lt;ProfilePage&gt;` props to `fetchUser(id)` and `fetchPosts(id)`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>`&lt;ProfilePage&gt;` の props に渡された `id` を `fetchUser(id)` と `fetchPosts(id)` に渡すように書き換えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/nervous-glade-b5sel)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/nervous-glade-b5sel)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note how we also changed the effect dependencies from `[]` to `[id]` — because we want the effect to re-run when the `id` changes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>`id` が変わるたびに副作用を再実行したいので、副作用の依存配列を `[]` から `[id]` に変えたことにも注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, we wouldn't refetch new data.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これをしなければ新しいデータの再取得ができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If we try this code, it might seem like it works at first.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このコードを試すと、最初はうまく動いているように見えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if we randomize the delay time in our "fake API" implementation and press the "Next" button fast enough, we'll see from the console logs that something is going very wrong.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>しかし、我々の「フェイク API」実装の遅延時間をランダム化し、"Next" ボタンを素早く押下すると、コンソールログで非常におかしなことが起きていることに気づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**Requests from the previous profiles may sometimes "come back" after we've already switched the profile to another ID -- and in that case they can overwrite the new state with a stale response for a different ID.**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**時々、プロフィールを別の ID に切り替えた後になって、以前のプロフィールのリクエストが「返ってくる」のです。その場合、別の ID 用の古いレスポンスによって、新しい state が上書きされてしまいます。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This problem is possible to fix (you could use the effect cleanup function to either ignore or cancel stale requests), but it's unintuitive and difficult to debug.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この問題は修正可能です（副作用のクリーンアップ関数を使って古いリクエストを無視ないしキャンセルするようにできます）が、直観的でなく、デバッグも困難です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Race Conditions with `componentDidUpdate` {#race-conditions-with-componentdidupdate}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### `componentDidUpdate` に伴う競合状態 {#race-conditions-with-componentdidupdate}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One might think that this is a problem specific to `useEffect` or Hooks.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これが `useEffect` つまりフックに特有の問題だと思っている人がいるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Maybe if we port this code to classes or use convenient syntax like `async` / `await`, it will solve the problem?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>コードをクラスに移植するか `async` / `await` のような便利な記法を使えば、もしかして問題が解決するのでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's try that:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>やってみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/trusting-clarke-8twuq)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/trusting-clarke-8twuq)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This code is deceptively easy to read.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>見た目ほど難しいことをしている訳ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unfortunately, neither using a class nor the `async` / `await` syntax helped us solve this problem.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>残念ながら、クラスを使っても `async` / `await` 構文を使っても、この問題は解決しませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This version suffers from exactly the same race conditions, for the same reasons.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このバージョンでも同じ理由により、全く同じような競合状態が発生しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### The Problem {#the-problem}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### 問題の本質 {#the-problem}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React components have their own "lifecycle".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>React コンポーネントはそれぞれ「ライフサイクル」を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They may receive props or update state at any point in time.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>props の受け取りや state の更新は任意のタイミングで起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, each asynchronous request *also* has its own "lifecycle".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>しかし非同期なリクエスト*も*それぞれの「ライフサイクル」を持っているのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It starts when we kick it off, and finishes when we get a response.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>リクエストを発行したときに始まり、レスポンスを得た時に終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difficulty we're experiencing is "synchronizing" several processes in time that affect each other.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>我々が直面している困難は互いに影響しあう複数のプロセスの「同期」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is hard to think about.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これは考えるのが難しい問題です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Solving Race Conditions with Suspense {#solving-race-conditions-with-suspense}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>### サスペンスで競合状態を解決する {#solving-race-conditions-with-suspense}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's rewrite this example again, but using Suspense only:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>この例を書き換えてサスペンスだけを使うようにしてみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/infallible-feather-xjtbu)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/infallible-feather-xjtbu)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the previous Suspense example, we only had one `resource`, so we held it in a top-level variable.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>以前の例では `resource` は 1 つだけだったのでトップレベルの変数として保持していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now that we have multiple resources, we moved it to the `&lt;App&gt;`'s component state:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>複数のリソースを使うようになったので、`&lt;App&gt;` のコンポーネント state に移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we click "Next", the `&lt;App&gt;` component kicks off a request for the next profile, and passes *that* object down to the `&lt;ProfilePage&gt;` component:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>"Next" をクリックすると、`&lt;App&gt;` コンポーネントは次のプロフィールのためのリクエストを発行し、*その*オブジェクトを `&lt;ProfilePage&gt;` コンポーネントに渡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Again, notice that **we're not waiting for the response to set the state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>繰り返しになりますが、**レスポンスを待機して state を設定するのではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's the other way around: we set the state (and start rendering) immediately after kicking off a request**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>その逆です。リクエスト開始の直後に state を設定して（そしてレンダーを開始して）います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As soon as we have more data, React "fills in" the content inside `&lt;Suspense&gt;` components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**データが到着するにつれて、React が `&lt;Suspense&gt;` コンポーネント内を中身で「埋めて」くれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This code is very readable, but unlike the examples earlier, the Suspense version doesn't suffer from race conditions.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>このコードは非常に読みやすいですが、これまでの例とは違い、サスペンスを使ったバージョンは競合状態による問題の影響を受けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You might be wondering why.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>どうしてなのか気になるでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The answer is that in the Suspense version, we don't have to think about *time* as much in our code.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>答えは、サスペンスを使ったバージョンではコード内で*時間*のことをさほど気にする必要がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our original code with race conditions needed to set the state *at the right moment later*, or otherwise it would be wrong.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>競合状態があった元のコードでは、state を*未来における正しいタイミングで*設定する必要があり、さもなくば間違った動作になっていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But with Suspense, we set the state *immediately* -- so it's harder to mess it up.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>しかしサスペンスでは state を*すぐに*設定するので、間違いが起きづらくなるのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Handling Errors {#handling-errors}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>## エラーの処理 {#handling-errors}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we write code with Promises, we might use `catch()` to handle errors.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>Promise を使ってコードを書く際は、`catch()` を使ってエラーを処理していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How does this work with Suspense, given that we don't *wait* for Promises to start rendering?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスでは Promise を使ってレンダー開始を*待つ*ことがないわけですが、エラー処理はどのようになるのでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With Suspense, handling fetching errors works the same way as handling rendering errors -- you can render an [error boundary](/docs/error-boundaries.html) anywhere to "catch" errors in components below.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスでは、データ取得のエラーの処理はレンダーのエラーと同様に動作します。配下のコンポーネントのエラーを "catch" するため、任意の場所で [error boundary](/docs/error-boundaries.html) をレンダーすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, we'll define an error boundary component to use across our project:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>まず、我々のプロジェクト全体で使う error boundary コンポーネントを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And then we can put it anywhere in the tree to catch errors:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>その後に、エラーをキャッチするためにツリーの任意の場所に配置します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/adoring-goodall-8wbn7)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/adoring-goodall-8wbn7)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It would catch both rendering errors *and* errors from Suspense data fetching.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これはレンダー中のエラーとサスペンスによるデータ取得時のエラーの*両方*をキャッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can have as many error boundaries as we like but it's best to [be intentional](https://aweary.dev/fault-tolerance-react/) about their placement.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>好きなだけ error boundary を配置することができますが、配置は[計画的](https://aweary.dev/fault-tolerance-react/)に行いましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Next Steps {#next-steps}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>## 次のステップ {#next-steps}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We've now covered the basics of Suspense for Data Fetching!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスによるデータ取得の基本について学びました！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Importantly, we now better understand *why* Suspense works this way, and how it fits into the data fetching space.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>重要なことは、サスペンスが*なぜ*このように動作し、そしてデータ取得の領域でなぜうまく動くのかについてよりよく理解できた、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suspense answers some questions, but it also poses new questions of its own:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>サスペンスによりいくつかの疑問が解決しましたが、新たな疑問も生じていることでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* If some component "suspends", does the app freeze?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* コンポーネントが "サスペンド" するとアプリはフリーズするのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How to avoid this?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>回避方法は？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* What if we want to show a spinner in a different place than "above" the component in a tree?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* コンポーネントツリーの「上側」以外の場所でスピナーを表示したい場合は？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* If we intentionally *want* to show an inconsistent UI for a small period of time, can we do that?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* 不整合な UI を意図的に短時間表示*したい*場合に、それは可能か？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Instead of showing a spinner, can we add a visual effect like "greying out" the current screen?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* スピナーを表示するのではなく「グレーアウト」のような視覚効果を加えることは可能か？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Why does our [last Suspense example](https://codesandbox.io/s/infallible-feather-xjtbu) log a warning when clicking the "Next" button?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>* [最後のサスペンスの例](https://codesandbox.io/s/infallible-feather-xjtbu)で "Next" ボタンをクリックしたときにログに警告が記録されているのは何故か？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To answer these questions, we will refer to the next section on [Concurrent UI Patterns](/docs/concurrent-mode-patterns.html).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T044734Z">
        <seg>これらの疑問に答えるために、次の記事、[並列的 UI パターン](/docs/concurrent-mode-patterns.html)に進みます。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
