<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.3.2_0_6a661c5e0" segtype="sentence" srclang="EN-US"/>
  <body>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>---
id: concurrent-mode-patterns
title: Concurrent UI Patterns (Experimental)
permalink: docs/concurrent-mode-patterns.html
prev: concurrent-mode-suspense.html
next: concurrent-mode-adoption.html
---</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>---
id: concurrent-mode-patterns
title: 並列的 UI パターン（実験的機能）
permalink: docs/concurrent-mode-patterns.html
prev: concurrent-mode-suspense.html
next: concurrent-mode-adoption.html
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;Caution:
&gt;
&gt;This page was about experimental features that aren't yet available in a stable release. It was aimed at early adopters and people who are curious.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>&gt;警告:
&gt;
&gt; このページはアーリーアダプターや興味のある読者を対象に、安定リリースでまだ利用できない実験的機能を説明するために存在していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;
&gt;Much of the information on this page is now outdated and exists only for archival purposes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>&gt;
&gt; このページの説明のほとんどは既に古くなっており、アーカイブの目的のためだけに残しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**Please refer to the [React 18 Alpha announcement post](/blog/2021/06/08/the-plan-for-react-18.html
) for the up-to-date information.**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>最新の情報については [React 18 アルファのアナウンス](/blog/2021/06/08/the-plan-for-react-18.html)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;
&gt;Before React 18 is released, we will replace this page with stable documentation.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>&gt;
&gt; React 18 のリリースまでに、このページはより安定したドキュメントに置き換わる予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Usually, when we update the state, we expect to see changes on the screen immediately.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>通常、state を更新した場合、画面に即座に変化が現れることを期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This makes sense because we want to keep our app responsive to user input.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ユーザ入力に対してアプリケーションをレスポンシブに保ちたいので、これは理にかなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, there are cases where we might prefer to **defer an update from appearing on the screen**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし、**画面に更新が現れるのを遅延**させたい場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if we switch from one page to another, and none of the code or data for the next screen has loaded yet, it might be frustrating to immediately see a blank page with a loading indicator.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>例えば、ある画面から別の画面に切り替えたいが、次の画面に必要なコードやデータが何もロードされていないという場合、切り替え直後に、ロード中インジケータだけがある空のページを見せられるのは煩わしいものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We might prefer to stay longer on the previous screen.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>前の画面にもうしばらく残りたいと思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implementing this pattern has historically been difficult in React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>歴史的に React ではこのパターンの実装は困難でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Concurrent Mode offers a new set of tools to do that.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>並列モードはこれを行うための新たなツール群を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Transitions](#transitions)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [トランジション](#transitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Wrapping setState in a Transition](#wrapping-setstate-in-a-transition)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [トランジション内で setState をラップする](#wrapping-setstate-in-a-transition)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Adding a Pending Indicator](#adding-a-pending-indicator)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [Pending インジケータの追加](#adding-a-pending-indicator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Reviewing the Changes](#reviewing-the-changes)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [変更のおさらい](#reviewing-the-changes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Where Does the Update Happen?](#where-does-the-update-happen)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [更新はどこで起こるのか？](#where-does-the-update-happen)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Transitions Are Everywhere](#transitions-are-everywhere)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [トランジションは至る所にある](#transitions-are-everywhere)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Baking Transitions Into the Design System](#baking-transitions-into-the-design-system)
- [The Three Steps](#the-three-steps)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [トランジションをデザインシステムに組み込む](#baking-transitions-into-the-design-system)
- [3 つのステップ](#the-three-steps)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Default: Receded → Skeleton → Complete](#default-receded-skeleton-complete)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [デフォルト：Receded → Skeleton → Complete](#default-receded-skeleton-complete)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Preferred: Pending → Skeleton → Complete](#preferred-pending-skeleton-complete)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [推奨：Pending → Skeleton → Complete](#preferred-pending-skeleton-complete)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Wrap Lazy Features in `&lt;Suspense&gt;`](#wrap-lazy-features-in-suspense)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [遅延可能な機能を `&lt;Suspense&gt;` でラップする](#wrap-lazy-features-in-suspense)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Suspense Reveal “Train”](#suspense-reveal-train)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [「電車」式のサスペンス開放](#suspense-reveal-train)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Delaying a Pending Indicator](#delaying-a-pending-indicator)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [Pending インジケータの遅延](#delaying-a-pending-indicator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Recap](#recap)
- [Other Patterns](#other-patterns)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [まとめ](#recap)
- [他のパターン](#other-patterns)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Splitting High and Low Priority State](#splitting-high-and-low-priority-state)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [高優先度 state と低優先度 state の分割](#splitting-high-and-low-priority-state)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [Deferring a Value](#deferring-a-value)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [値の遅延](#deferring-a-value)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>- [SuspenseList](#suspenselist)
- [Next Steps](#next-steps)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>- [SuspenseList](#suspenselist)
- [次のステップ](#next-steps)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Transitions {#transitions}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>## トランジション {#transitions}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's revisit [this demo](https://codesandbox.io/s/infallible-feather-xjtbu) from the previous page about [Suspense for Data Fetching](/docs/concurrent-mode-suspense.html).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>前のページ、[サスペンスを使ったデータ取得](/docs/concurrent-mode-suspense.html)にある[こちらのデモ](https://codesandbox.io/s/infallible-feather-xjtbu)について改めて考えましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we click the "Next" button to switch the active profile, the existing page data immediately disappears, and we see the loading indicator for the whole page again.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>"Next" ボタンをクリックしてアクティブなプロフィールを切り替えた際、既存のページデータは即座に消えて、新しい画面のためのローディングインジケータを見ることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can call this an "undesirable" loading state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは「望ましくない」ローディング中状態と呼べるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**It would be nice if we could "skip" it and wait for some content to load before transitioning to the new screen.**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**これをスキップして、新しい画面に遷移 (transition) する前に新しいコンテンツがロードされるのを待機できれば良さそうです。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React offers a new built-in `useTransition()` Hook to help with this.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>React はこれを補助するために `useTransition()` という新しい組み込みフックを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can use it in three steps.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは以下の 3 ステップで利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, we'll make sure that we're actually using Concurrent Mode.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>まず、実際に並列モードを利用していることを確かめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll talk more about [adopting Concurrent Mode](/docs/concurrent-mode-adoption.html) later, but for now it's sufficient to know that we need to use `ReactDOM.createRoot()` rather than `ReactDOM.render()` for this feature to work:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>後で[並列モードの利用開始](/docs/concurrent-mode-adoption.html)方法については述べますが、今のところは `ReactDOM.render()` の代わりに `ReactDOM.createRoot()` を使うことでこの機能が使える、ということを知っていれば十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, we'll add an import for the `useTransition` Hook from React:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>次に、React から `useTransition` フックをインポートする文を追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, we'll use it inside the `App` component:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>最後に、`App` コンポーネント内でそれを利用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**By itself, this code doesn't do anything yet.** We will need to use this Hook's return values to set up our state transition.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**このコードはそれ自体ではまだ何もしません。**このフックの戻り値を使って state のトランジションをセットアップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two values returned from `useTransition`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`useTransition` からの戻り値は 2 つです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* `startTransition` is a function.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* `startTransition` は関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll use it to tell React *which* state update we want to defer.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これを使って、*どの* state の更新を遅延させたいのかを React に伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* `isPending` is a boolean.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* `isPending` は真偽値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's React telling us whether that transition is ongoing at the moment.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>React はこれを使って現在トランジションが進行中かどうかを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We will use them right below.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このすぐ後で使ってみます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note we passed a configuration object to `useTransition`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`useTransition` に設定オブジェクトを渡したことに気をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Its `timeoutMs` property specifies **how long we're willing to wait for the transition to finish**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この `timeoutMs` プロパティで**トランジションが終了するまでどれだけ待てるか**を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By passing `{timeoutMs: 3000}`, we say "If the next profile takes more than 3 seconds to load, show the big spinner -- but before that timeout it's okay to keep showing the previous screen".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`{timeoutMs: 3000}` を渡すことで、「次のプロフィール画面がロードされるのに 3 秒以上かかったら、大きなスピナーを表示せよ、ただしそれまでは前の画面を表示しつづけていて構わない」ということを伝えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Wrapping setState in a Transition {#wrapping-setstate-in-a-transition}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### トランジション内で setState をラップする {#wrapping-setstate-in-a-transition}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our "Next" button click handler sets the state that switches the current profile in the state:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>"Next" ボタンのクリックハンドラは、現在のプロフィールを切り替えるための state を設定しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll wrap that state update into `startTransition`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この state の更新を `startTransition` でラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That's how we tell React **we don't mind React delaying that state update** if it leads to an undesirable loading state:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これが、もしこの state の更新によって望ましくないローディング中状態の表示が起きる場合、**React がこの state 更新を遅延させても構わない**、と React に伝える方法です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/musing-driscoll-6nkie)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/musing-driscoll-6nkie)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Press "Next" a few times.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>何度か "Next" を押してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice it already feels very different.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>既に大きく違っていることが分かるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**Instead of immediately seeing an empty screen on click, we now keep seeing the previous page for a while.** When the data has loaded, React transitions us to the new screen.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**クリック直後に空の画面を見せられる代わりに、しばらくは前のページが表示され続けます。**データがロードされたら、React が次の画面に遷移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If we make our API responses take 5 seconds, [we can confirm](https://codesandbox.io/s/relaxed-greider-suewh) that now React "gives up" and transitions anyway to the next screen after 3 seconds.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>もし API のレスポンスを 5 秒かかるように変えると、React は 3 秒後に「諦めて」、ともかく画面の遷移を行うことが[確認できます](https://codesandbox.io/s/relaxed-greider-suewh)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is because we passed `{timeoutMs: 3000}` to `useTransition()`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは `useTransition()` に `{timeoutMs: 3000}` を渡したからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if we passed `{timeoutMs: 60000}` instead, it would wait a whole minute.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>もし `{timeoutMs: 60000}` を代わりに渡したら、丸々 1 分間待つことになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Adding a Pending Indicator {#adding-a-pending-indicator}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### Pending インジケータの追加 {#adding-a-pending-indicator}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's still something that feels broken about [our last example](https://codesandbox.io/s/musing-driscoll-6nkie).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>[前回の例](https://codesandbox.io/s/musing-driscoll-6nkie)にはまだうまく行っていないところがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sure, it's nice not to see a "bad" loading state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>「望ましくない」ローディング中状態は、もちろん見えない方がいいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**But having no indication of progress at all feels even worse!** When we click "Next", nothing happens and it feels like the app is broken.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**ですが進行状況が一切見えないのはもっとダメに感じられます！** "Next" をクリックして何も起こらなかったなら、アプリケーションが壊れているように思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our `useTransition()` call returns two values: `startTransition` and `isPending`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`useTransition()` の呼び出しは、2 つの値を返します。`startTransition` と `isPending` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We've already used `startTransition` to wrap the state update.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`startTransition` はもう使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now we're going to use `isPending` too.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ここで `isPending` も使うようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React gives this boolean to us so we can tell whether **we're currently waiting for this transition to finish**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>React がこの真偽値を渡してくれることで、**このトランジションの完了を待っているところかどうか**が分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll use it to indicate that something is happening:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>何かが起こっている、ということを示すためにこれを使いましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/jovial-lalande-26yep)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/jovial-lalande-26yep)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now, this feels a lot better!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ずっと良く感じられるようになりました！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we click Next, it gets disabled because clicking it multiple times doesn't make sense.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>"Next" をクリックすると、何度も押しても意味がないのでボタンは無効化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And the new "Loading..." tells the user that the app didn't freeze.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>そして新たに表示される "Loading..." が、ユーザにアプリケーションがフリーズしていないということを伝えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Reviewing the Changes {#reviewing-the-changes}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### 変更のおさらい {#reviewing-the-changes}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's take another look at all the changes we've made since the [original example](https://codesandbox.io/s/infallible-feather-xjtbu):</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>[元の例](https://codesandbox.io/s/infallible-feather-xjtbu)以降に行った変更をもう一度すべて見てみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/jovial-lalande-26yep)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/jovial-lalande-26yep)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It took us only seven lines of code to add this transition:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このトランジションを加えるのに必要だったコードはわずか 7 行でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* We've imported the `useTransition` Hook and used it in the component that updates the state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* `useTransition` フックをインポートして、state を更新するコンポーネント内で使いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* We've passed `{timeoutMs: 3000}` to stay on the previous screen for at most 3 seconds.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* `{timeoutMs: 3000}` を渡すことで、最高 3 秒間は前の画面に留まるようにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* We've wrapped our state update into `startTransition` to tell React it's okay to delay it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* state の更新を `startTransition` でラップし、この更新は遅延可能であると伝えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* We're using `isPending` to communicate the state transition progress to the user and to disable the button.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* `isPending` を使って、ユーザにトランジションの進行状況を伝えるとともに、ボタンを無効化しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, clicking "Next" doesn't perform an immediate state transition to an "undesirable" loading state, but instead stays on the previous screen and communicates progress there.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>結果として、"Next" をクリックしても「望ましくない」ローディング中状態に直接遷移するのではなく、前の画面に留まってユーザに進行状況を伝えるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Where Does the Update Happen?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### 更新はどこで起こるのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This wasn't very difficult to implement.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これを実装するのはあまり難しくありませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if you start thinking about how this could possibly work, it might become a little mindbending.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかしこれがどうやって動作しているのかを考え始めると、ちょっと混乱しそうになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If we set the state, how come we don't see the result right away?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>state を設定したのに、なぜその結果がすぐ現れなかったのでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>*Where* is the next `&lt;ProfilePage&gt;` rendering?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>次の `&lt;ProfilePage&gt;` は*どこで*レンダーされているのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Clearly, both "versions" of `&lt;ProfilePage&gt;` exist at the same time.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>明らかに、`&lt;ProfilePage&gt;` の両方の「バージョン」が同時に存在しているのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We know the old one exists because we see it on the screen and even display a progress indicator on it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>古いバージョンが存在していることは、画面に表示されており進行中のインジケータまで表示しているということから分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And we know the new version also exists *somewhere*, because it's the one that we're waiting for!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>また新しいバージョンが*どこかに*存在しているということも分かります。まさにそれが完了するのを待っているのですから！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**But how can two versions of the same component exist at the same time?**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**ですが、同じコンポーネントの 2 つのバージョンがどうやって同時に存在できるのでしょうか？**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This gets at the root of what Concurrent Mode is.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これが並列モードの根幹にあたる部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We've [previously said](/docs/concurrent-mode-intro.html#intentional-loading-sequences) it's a bit like React working on state update on a "branch".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは React が state の更新を「ブランチ」で行っているようなものであると[以前述べました](/docs/concurrent-mode-intro.html#intentional-loading-sequences)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another way we can conceptualize is that wrapping a state update in `startTransition` begins rendering it *"in a different universe"*, much like in science fiction movies.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これを概念化する別の方法として、`startTransition` で state の更新をラップすることで、SF 映画のごとくレンダーが*「別の宇宙で」*始まるのだと考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We don't "see" that universe directly -- but we can get a signal from it that tells us something is happening (`isPending`).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>その宇宙を直接「見る」ことはできません -- しかしその宇宙からは何かが起きているという信号 (`isPending`) を得ることはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the update is ready, our "universes" merge back together, and we see the result on the screen!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>更新の準備が完了したところで、「2 つの宇宙」がマージされ、画面に結果が表示されます！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Play a bit more with the [demo](https://codesandbox.io/s/jovial-lalande-26yep), and try to imagine it happening.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>[デモ](https://codesandbox.io/s/jovial-lalande-26yep)で遊んでみて、そのようなことが起きているところを想像してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Of course, two versions of the tree rendering *at the same time* is an illusion, just like the idea that all programs run on your computer at the same time is an illusion.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>もちろん、ツリーの 2 つのバージョンが*同時に*レンダーされているというのは錯覚であり、それはあなたのコンピュータ上のプログラムが全部同時に実行されていると考えることが錯覚であるのと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An operating system switches between different applications very fast.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>オペレーティング・システムは複数のアプリケーションを非常に素早く切り替えているのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, React can switch between the version of the tree you see on the screen and the version that it's "preparing" to show next.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>同様に React は、画面上に見えているツリーのバージョンと、次に表示されるために「準備中」のバージョンとを切り替えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An API like `useTransition` lets you focus on the desired user experience, and not think about the mechanics of how it's implemented.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`useTransition` のような API を使うことで、望ましいユーザ体験に集中でき、それがどのような仕組みで実現されているのかについて気にしないでよくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Still, it can be a helpful metaphor to imagine that updates wrapped in `startTransition` happen "on a branch" or "in a different world".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>それでも、`startTransition` でラップした更新が「ブランチ」や「別世界」で起こっていると想像するのは例え話としては有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Transitions Are Everywhere {#transitions-are-everywhere}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### トランジションは至る所にある {#transitions-are-everywhere}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As we learned from the [Suspense walkthrough](/docs/concurrent-mode-suspense.html), any component can "suspend" any time if some data it needs is not ready yet.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>[サスペンスの解説](/docs/concurrent-mode-suspense.html)で学んだ通り、コンポーネントはそれが必要とするデータがまだ準備できていない場合にいつでも「サスペンド」することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can strategically place `&lt;Suspense&gt;` boundaries in different parts of the tree to handle this, but it won't always be enough.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>計画的にツリー内の様々な場所に `&lt;Suspense&gt;` バウンダリを配置することでこれを制御できますが、それでは十分でないことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's get back to our [first Suspense demo](https://codesandbox.io/s/frosty-hermann-bztrp) where there was just one profile.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>プロフィールが 1 つだけだった最初の[サスペンスのデモ](https://codesandbox.io/s/frosty-hermann-bztrp)に戻りましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Currently, it fetches the data only once.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>今のところはデータを 1 回だけ取得しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll add a "Refresh" button to check for server updates.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>サーバ側に更新があるかを確認する "Refresh" ボタンを追加しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our first attempt might look like this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>まずはこのようにしてみました：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/boring-shadow-100tf)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/boring-shadow-100tf)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, we start data fetching at the load *and* every time you press "Refresh".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この例では、ロード時**および** "Refresh" を押下する度に、データ取得が開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We put the result of calling `fetchUserAndPosts()` into state so that components below can start reading the new data from the request we just kicked off.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`fetchUserAndPosts()` を呼び出した結果を state 内に入れることで、配下のコンポーネントがたった今開始したリクエストから新しいデータを読み出せるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can see in [this example](https://codesandbox.io/s/boring-shadow-100tf) that pressing "Refresh" works.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>[こちら](https://codesandbox.io/s/boring-shadow-100tf)で試せるとおり、"Refresh" ボタンの押下は動作はしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The `&lt;ProfileDetails&gt;` and `&lt;ProfileTimeline&gt;` components receive a new `resource` prop that represents the fresh data, they "suspend" because we don't have a response yet, and we see the fallbacks.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`&lt;ProfileDetails&gt;` と `&lt;ProfileTimeline&gt;` コンポーネントは新しいデータを表す `resource` を props として受け取り、レスポンスがまだ存在しないため「サスペンド」し、フォールバックが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the response loads, we can see the updated posts (our fake API adds them every 3 seconds).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>レスポンスがロードされると、更新されたタイムライン投稿を見ることができます（フェイク API は 3 秒ごとに投稿を追加するようになっています）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the experience feels really jarring.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかしながらユーザ体験はとても煩わしいものとなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We were browsing a page, but it got replaced by a loading state right as we were interacting with it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ページをブラウズしているのに、操作の真っ最中にページがローディング中状態で置き換わってしまうのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's disorienting.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これはユーザを混乱させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**Just like before, to avoid showing an undesirable loading state, we can wrap the state update in a transition:**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**これまでと同様に、望ましくないローディング中状態を回避するために、state の更新をトランジションでラップできます：**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/sleepy-field-mohzb)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/sleepy-field-mohzb)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This feels a lot better!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ずっと良く感じられます！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Clicking "Refresh" doesn't pull us away from the page we're browsing anymore.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>"Refresh" をクリックすることで今ブラウズしていたページから引き離されることがなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We see something is loading "inline", and when the data is ready, it's displayed.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>何かがロード中であると「インライン」で見ることができ、データの準備が完了したらそれが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Baking Transitions Into the Design System {#baking-transitions-into-the-design-system}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### トランジションをデザインシステムに組み込む {#baking-transitions-into-the-design-system}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can now see that the need for `useTransition` is *very* common.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これで `useTransition` の要求は*非常に*よくあるものであることが分かったでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pretty much any button click or interaction that can lead to a component suspending needs to be wrapped in `useTransition` to avoid accidentally hiding something the user is interacting with.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>コンポーネントのサスペンドを引き起こすような、ほぼあらゆるボタンクリックやユーザ操作は、`useTransition` でラップして、ユーザが触っていたものをうっかり隠さないようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This can lead to a lot of repetitive code across components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これはコンポーネント間で多くのコードの反復を引き起こす可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is why **we generally recommend to bake `useTransition` into the *design system* components of your app**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このため、**`useTransition` を*デザインシステム*コンポーネントに組み込む**ことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, we can extract the transition logic into our own `&lt;Button&gt;` component:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>例えば、トランジションのロジックを独自の `&lt;Button&gt;` コンポーネントに抽出することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/modest-ritchie-iufrh)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/modest-ritchie-iufrh)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the button doesn't care *what* state we're updating.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このボタンは*何の* state を更新しようとしているのか関知しないということに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's wrapping *any* state updates that happen during its `onClick` handler into a transition.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは `onClick` ハンドラ内部で起こる*あらゆる* state の更新をトランジションでラップしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now that our `&lt;Button&gt;` takes care of setting up the transition, the `&lt;ProfilePage&gt;` component doesn't need to set up its own:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これで `&lt;Button&gt;` がトランジションの作成を行ってくれるようになったので、`&lt;ProfilePage&gt;` コンポーネントがそれを自ら作成する必要がなくなりました：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/modest-ritchie-iufrh)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/modest-ritchie-iufrh)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a button gets clicked, it starts a transition and calls `props.onClick()` inside of it -- which triggers `handleRefreshClick` in the `&lt;ProfilePage&gt;` component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ボタンがクリックされると、トランジションが開始され、内部の `props.onClick()` が呼び出されます。それが `&lt;ProfilePage&gt;` コンポーネント内の `handleRefreshClick` をトリガします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We start fetching the fresh data, but it doesn't trigger a fallback because we're inside a transition, and the 10 second timeout specified in the `useTransition` call hasn't passed yet.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>新しいデータの取得が開始されますが、トランジションの内部におり、かつ `useTransition` 呼び出しで指定されている 10 秒のタイムアウトがまだ経過していないため、フォールバックは呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While a transition is pending, the button displays an inline loading indicator.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>トランジションが進行している間、ボタンはインラインでローディングインジケータを表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can see now how Concurrent Mode helps us achieve a good user experience without sacrificing isolation and modularity of components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これで、コンポーネントの独立性やモジュール性を犠牲にすることなく良いユーザ体験を実現するのに、並列モードがどのように役立つのかが分かったと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React coordinates the transition.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>React がトランジションの調整を行うのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## The Three Steps {#the-three-steps}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>## 3 つのステップ {#the-three-steps}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By now we have discussed all of the different visual states that an update may go through.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ここまでで、更新があったときに経由する可能性のある視覚的な状態についてすべて説明しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this section, we will give them names and talk about the progression between them.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このセクションでは、それらに名前を付け、それらの間での連続性について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At the very end, we have the **Complete** state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>最後に存在しているのは **Complete** 状態です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That's where we want to eventually get to.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ここが最終的に到達したい状態です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It represents the moment when the next screen is fully rendered and isn't loading more data.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>次画面が完全に描画されており、それ以上データを読み込んでいないタイミングを表しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But before our screen can be Complete, we might need to load some data or code.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし画面が Complete になる前に、何らかのデータやコードを読み込む必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we're on the next screen, but some parts of it are still loading, we call that a **Skeleton** state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>次画面を表示はしているが、その中の一部がまだロード中である場合、それを **Skeleton** 状態と呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, there are two primary ways that lead us to the Skeleton state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>最後に、Skeleton 状態に至るまでの経路が主に 2 つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We will illustrate the difference between them with a concrete example.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>具体的な例を使ってそれらの違いを述べたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Default: Receded → Skeleton → Complete {#default-receded-skeleton-complete}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### デフォルト：Receded → Skeleton → Complete {#default-receded-skeleton-complete}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Open [this example](https://codesandbox.io/s/prod-grass-g1lh5) and click "Open Profile".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>[こちらの例](https://codesandbox.io/s/prod-grass-g1lh5)を開いて "Open Profile" をクリックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You will see several visual states one by one:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>複数の視覚的な状態を 1 つずつ見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **Receded**: For a second, you will see the `<bpt i="1" x="1">&lt;h1&gt;</bpt>Loading the app...<ept i="1">&lt;/h1&gt;</ept>` fallback.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* **Receded**: 1 秒間、`<bpt i="1" x="1">&lt;h1&gt;</bpt>Loading the app...<ept i="1">&lt;/h1&gt;</ept>` フォールバックが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **Skeleton:** You will see the `&lt;ProfilePage&gt;` component with `<bpt i="2" x="2">&lt;h2&gt;</bpt>Loading posts...<ept i="2">&lt;/h2&gt;</ept>` inside.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* **Skeleton:** `&lt;ProfilePage&gt;` コンポーネントが表示され、中で `<bpt i="2" x="2">&lt;h2&gt;</bpt>Loading posts...<ept i="2">&lt;/h2&gt;</ept>` が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **Complete:** You will see the `&lt;ProfilePage&gt;` component with no fallbacks inside.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* **Complete:** `&lt;ProfilePage&gt;` コンポーネントが表示され、内部のフォールバックも表示されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Everything was fetched.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>すべてのデータは取得済みです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How do we separate the Receded and the Skeleton states?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>Receded 状態と Skeleton 状態はどのように区別するのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difference between them is that the **Receded** state feels like "taking a step back" to the user, while the **Skeleton** state feels like "taking a step forward" in our progress to show more content.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これらの違いは、**Receded** 状態はユーザからは「一歩後退中」のように見え、**Skeleton** 状態はより多くのコンテンツを見せるべく「一歩前進中」のように見えるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, we started our journey on the `&lt;HomePage&gt;`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>今回の例は `&lt;HomePage&gt;` 画面から始まっています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the click, React started rendering the next screen:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>クリックすることで React は次の画面のレンダーを始めました：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both `&lt;ProfileDetails&gt;` and `&lt;ProfileTimeline&gt;` need data to render, so they suspend:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`&lt;ProfileDetails&gt;` も `&lt;ProfileTimeline&gt;` もレンダーするのにデータが必要なので、サスペンドします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a component suspends, React needs to show the closest fallback.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>コンポーネントがサスペンドすると、React は直近にあるフォールバックを表示する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But the closest fallback to `&lt;ProfileDetails&gt;` is at the top level:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし `&lt;ProfileDetails&gt;` の直近のフォールバックはトップレベルにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is why when we click the button, it feels like we've "taken a step back".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これがボタンをクリックしたときに「一歩後退した」ように感じられる理由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The `&lt;Suspense&gt;` boundary which was previously showing useful content (`&lt;HomePage /&gt;`) had to "recede" to showing the fallback (`<bpt i="1" x="1">&lt;h1&gt;</bpt>Loading the app...<ept i="1">&lt;/h1&gt;</ept>`).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>既に意味のあるコンテンツを表示していた `&lt;Suspense&gt;` バウンダリが一歩後退 (recede) してフォールバック (`<bpt i="1" x="1">&lt;h1&gt;</bpt>Loading the app...<ept i="1">&lt;/h1&gt;</ept>`) を表示しなければなりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We call that a **Receded** state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このことを **Receded** 状態と呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As we load more data, React will retry rendering, and `&lt;ProfileDetails&gt;` can render successfully.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>データをロードするにつれて、React は再レンダーを試み、`&lt;ProfileDetails&gt;` はうまく表示されるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, we're in the **Skeleton** state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ついに **Skeleton** 状態に来たわけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We see the new page with missing parts:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>一部が欠けた新しいページが見えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Eventually, they load too, and we get to the **Complete** state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>いずれ欠けている部分もロードされ、**Complete** 状態に至ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This scenario (Receded → Skeleton → Complete) is the default one.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このシナリオ (Receded → Skeleton → Complete) がデフォルトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the Receded state is not very pleasant because it "hides" existing information.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし、Receded 状態は既に存在する情報を「隠す」ことになるのであまり嬉しいものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is why React lets us opt into a different sequence (**Pending** → Skeleton → Complete) with `useTransition`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これが React が `useTransition` によって別のシーケンス (**Pending** → Skeleton → Complete) を利用できるようにしている理由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Preferred: Pending → Skeleton → Complete {#preferred-pending-skeleton-complete}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### 推奨：Pending → Skeleton → Complete {#preferred-pending-skeleton-complete}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we `useTransition`, React will let us "stay" on the previous screen -- and show a progress indicator there.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`useTransition` を使うと、React は前の画面に「留まって」、そちらで進行状況のインジケータを表示できるようにさせてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We call that a **Pending** state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この状態を **Pending** 状態と呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It feels much better than the Receded state because none of our existing content disappears, and the page stays interactive.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは既存のコンテンツが消えてしまうことがなく、ページの操作性が保たれるので、Receded 状態よりもずっと良いものに感じられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can compare these two examples to feel the difference:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>以下の 2 つの例を比較して、違いを感じてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Default: [Receded → Skeleton → Complete](https://codesandbox.io/s/prod-grass-g1lh5)
* **Preferred: [Pending → Skeleton → Complete](https://codesandbox.io/s/focused-snow-xbkvl)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* デフォルト：[Receded → Skeleton → Complete](https://codesandbox.io/s/prod-grass-g1lh5)
* **推奨：[Pending → Skeleton → Complete](https://codesandbox.io/s/focused-snow-xbkvl)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The only difference between these two examples is that the first uses regular `&lt;button&gt;`s, but the second one uses our custom `&lt;Button&gt;` component with `useTransition`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この 2 つの例の唯一の違いは、前者が標準の `&lt;button&gt;` を使っており、後者は `useTransition` を使ったカスタムの `&lt;Button&gt;` を使っている、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Wrap Lazy Features in `&lt;Suspense&gt;` {#wrap-lazy-features-in-suspense}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### 遅延可能な機能を `&lt;Suspense&gt;` でラップする {#wrap-lazy-features-in-suspense}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Open [this example](https://codesandbox.io/s/nameless-butterfly-fkw5q).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>[こちらの例](https://codesandbox.io/s/nameless-butterfly-fkw5q)を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you press a button, you'll see the Pending state for a second before moving on.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ボタンを押下すると、先に進む前に Pending 状態が 1 秒間表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This transition feels nice and fluid.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このトランジションはスムースで良いものに感じられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We will now add a brand new feature to the profile page -- a list of fun facts about a person:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ここでプロフィールページに新たな機能を付け加えましょう -- その人に関する豆知識（トリビア）のリストです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/focused-mountain-uhkzg)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/focused-mountain-uhkzg)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you press "Open Profile" now, you can tell something is wrong.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>"Open Profile" を押下すると、何かおかしいことに気付くでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It takes a whole seven seconds to make the transition now!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>トランジションが完了するまで丸々 7 秒間もかかっているのです！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is because our trivia API is too slow.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは我々のトリビア API がとても遅いからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's say we can't make the API faster.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>仮に、この API はこれ以上高速化できないということにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How can we improve the user experience with this constraint?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この制限下で、ユーザ体験をどのように向上させればよいでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If we don't want to stay in the Pending state for too long, our first instinct might be to set `timeoutMs` in `useTransition` to something smaller, like `3000`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>Pending 状態にあまり留まりたくないという場合、直感的には `useTransition` の `timeoutMs` を小さな値、例えば `3000` にすればよいと思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can try this [here](https://codesandbox.io/s/practical-kowalevski-kpjg4).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これを[こちら](https://codesandbox.io/s/practical-kowalevski-kpjg4)で試すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This lets us escape the prolonged Pending state, but we still don't have anything useful to show!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これで遷延している Pending 状態から脱出することはできますが、意味のある内容はまだ何も表示されません！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is a simpler way to solve this.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>よりシンプルな解決法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**Instead of making the transition shorter, we can "disconnect" the slow component from the transition** by wrapping it into `&lt;Suspense&gt;`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**トランジションを短くするのではなく、遅いコンポーネントをトランジションから「切り離し」する**ために、`&lt;Suspense&gt;` でラップするのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/condescending-shape-s6694)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/condescending-shape-s6694)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This reveals an important insight.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ここに重要な見識が見いだされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React always prefers to go to the Skeleton state as soon as possible.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>React は常に可能な限り速く Skeleton 状態に移行しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even if we use transitions with long timeouts everywhere, React will not stay in the Pending state for longer than necessary to avoid the Receded state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>長いタイムアウトをあらゆる場所で使ったとしても、React は、Receded 状態を避けるために必要な時間を超えて Pending 状態に留まるということをしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**If some feature isn't a vital part of the next screen, wrap it in `&lt;Suspense&gt;` and let it load lazily.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**ある機能が次の画面に必須なものではない場合は、それを `&lt;Suspense&gt;` でラップして、遅延読み込みさせてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>** This ensures we can show the rest of the content as soon as possible.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**これにより、残りのコンテンツを可能な限り素早く表示できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversely, if a screen is *not worth showing* without some component, such as `&lt;ProfileDetails&gt;` in our example, do *not* wrap it in `&lt;Suspense&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>逆に、あるコンポーネントがないと次の画面の*表示自体が無価値*であるという場合（例えば我々の例の `&lt;ProfileDetails&gt;`）、そのコンポーネントを `&lt;Suspense&gt;` で囲んでは*いけません*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Then the transitions will "wait" for it to be ready.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>こうすることで、トランジションはそれが準備できるまで「待つ」ようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Suspense Reveal "Train" {#suspense-reveal-train}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### 「電車」式のサスペンス開放 {#suspense-reveal-train}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we're already on the next screen, sometimes the data needed to "unlock" different `&lt;Suspense&gt;` boundaries arrives in quick succession.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>既に次の画面にいるとして、時に複数の `&lt;Suspense&gt;` バウンダリを開放 (unlock) するのに必要なデータが矢継ぎ早にやってくるということがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, two different responses might arrive after 1000ms and 1050ms, respectively.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>例えば、2 つの異なったレスポンスがそれぞれ 1000ms 後と 1050ms 後にやってくる、ということがあるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you've already waited for a second, waiting another 50ms is not going to be perceptible.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>既に 1 秒間待っていたのなら、追加で 50ms 待ったとしても知覚できないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is why React reveals `&lt;Suspense&gt;` boundaries on a schedule, like a "train" that arrives periodically.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このため、React は `&lt;Suspense&gt;` バウンダリ内のコンテンツを、一定間隔でやってくる「電車」のように、定期的に開放します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This trades a small delay for reducing the layout thrashing and the number of visual changes presented to the user.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これで、僅かな遅延と引き替えに、バタバタとレイアウトを行ってユーザに視覚上の変化を見せる回数を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can see a demo of this [here](https://codesandbox.io/s/admiring-mendeleev-y54mk).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>このデモを[こちら](https://codesandbox.io/s/admiring-mendeleev-y54mk)で見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The "posts" and "fun facts" responses come within 100ms of each other.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>タイムライン投稿用と豆知識用のレスポンスは 100 ミリ秒未満の時間差で返ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But React coalesces them and "reveals" their Suspense boundaries together.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし React はそれらを結合してサスペンスのバウンダリをまとめて「開放」します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Delaying a Pending Indicator {#delaying-a-pending-indicator}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### Pending インジケータの遅延 {#delaying-a-pending-indicator}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our `Button` component will immediately show the Pending state indicator on click:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>我々の `Button` コンポーネントはクリックした直後に Pending 状態のインジケータを表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/floral-thunder-iy826)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/floral-thunder-iy826)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This signals to the user that some work is happening.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これにより何らかの作業が行われているとユーザに伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if the transition is relatively short (less than 500ms), it might be too distracting and make the transition itself feel *slower*.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし、トランジションが比較的短い場合（500ms 以内）、これにより気が散ってしまい、トランジション自体が*遅く*感じられるようになってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One possible solution to this is to *delay the spinner itself* from displaying:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>解決法の 1 つは、*スピナー自体*の表示を遅延させることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/gallant-spence-l6wbk)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/gallant-spence-l6wbk)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With this change, even though we're in the Pending state, we don't display any indication to the user until 500ms has passed.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この変更により、Pending 状態にいる場合でも、500 ms が経過するまでは何のインジケータも表示しないようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This may not seem like much of an improvement when the API responses are slow.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは API のレスポンスが遅い場合には大した改善のように思えないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But compare how it feels [before](https://codesandbox.io/s/thirsty-liskov-1ygph) and [after](https://codesandbox.io/s/hardcore-http-s18xr) when the API call is fast.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし API 呼び出しが速い場合にどう違って感じられるか、[改善前](https://codesandbox.io/s/thirsty-liskov-1ygph)と[改善後](https://codesandbox.io/s/hardcore-http-s18xr)を比較してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though the rest of the code hasn't changed, suppressing a "too fast" loading state improves the perceived performance by not calling attention to the delay.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>コードの残りの部分は変わっていないにもかかわらず、「あまりに早すぎる」ロード中状態を抑制すると、遅延に意識を向けさせないことにより体感上のパフォーマンスは向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Recap {#recap}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### まとめ {#recap}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most important things we learned so far are:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ここまでで学んだ重要なことは以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* By default, our loading sequence is Receded → Skeleton → Complete.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* デフォルトでは、ローディングシーケンスは Receded → Skeleton → Complete である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The Receded state doesn't feel very nice because it hides existing content.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* Receded 状態は既存のコンテンツを隠してしまうため体感上良く感じられない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* With `useTransition`, we can opt into showing a Pending state first instead.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* `useTransition` を使ことで、選択的に Pending 状態を表示するようにできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This will keep us on the previous screen while the next screen is being prepared.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これにより次の画面の準備をしている間、前の画面に留まることが可能になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* If we don't want some component to delay the transition, we can wrap it in its own `&lt;Suspense&gt;` boundary.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* あるコンポーネントによりトランジションが遅延するのを避けたい場合、それを個別の `&lt;Suspense&gt;` バウンダリでラップする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Instead of doing `useTransition` in every other component, we can build it into our design system.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>* `useTransition` をあらゆるコンポーネントで使う代わりに、デザインシステムに組み込むことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Other Patterns {#other-patterns}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>## 他のパターン {#other-patterns}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Transitions are probably the most common Concurrent Mode pattern you'll encounter, but there are a few more patterns you might find useful.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>トランジションは、並列モードにおいておそらく最も一般的に遭遇するパターンですが、他にも有用かもしれないパターンが幾つかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Splitting High and Low Priority State {#splitting-high-and-low-priority-state}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### 高優先度 state と低優先度 state の分割 {#splitting-high-and-low-priority-state}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you design React components, it is usually best to find the "minimal representation" of state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>React コンポーネントの設計において、通常は state の「最小の表現」を見つけることがベストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, instead of keeping `firstName`, `lastName`, and `fullName` in state, it's usually better keep only `firstName` and `lastName`, and then calculate `fullName` during rendering.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>例えば、`firstName`、`lastName` と `fullName` を state に保持するよりも、`firstName` と `lastName` だけを保持して `fullName` はレンダー中に計算する方が通常は望ましいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This lets us avoid mistakes where we update one state but forget the other state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これにより片方の state を更新してもう片方の state のことを忘れるという間違いを避けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, in Concurrent Mode there are cases where you might *want* to "duplicate" some data in different state variables.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし並列モードでは、複数の state 変数にあるデータを「重複」*させたい*という場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Consider this tiny translation app:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>以下のミニ翻訳アプリを考えてみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/brave-villani-ypxvf)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/brave-villani-ypxvf)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice how when you type into the input, the `&lt;Translation&gt;` component suspends, and we see the `&lt;p&gt;Loading...&lt;/p&gt;` fallback until we get fresh results.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>入力欄にタイプすると `&lt;Translation&gt;` コンポーネントがサスペンドし、新しい翻訳結果が手に入るまで `&lt;p&gt;Loading...&lt;/p&gt;` というフォールバックが表示されることに気付くでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is not ideal.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは良くありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It would be better if we could see the *previous* translation for a bit while we're fetching the next one.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>新しい翻訳結果を取得している間、*前の*翻訳結果が表示されつづけている方が望ましいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, if we open the console, we'll see a warning:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>実は、コンソールを開くと、以下のような警告が表示されています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As we mentioned earlier, if some state update causes a component to suspend, that state update should be wrapped in a transition.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>以前述べたとおり、state の更新がコンポーネントのサスペンドを引き起こす場合、その state 更新はトランジションでラップされるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's add `useTransition` to our component:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ではこのコンポーネントに `useTransition` を追加してみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/zen-keldysh-rifos)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/zen-keldysh-rifos)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Try typing into the input now.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>入力欄でタイピングしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Something's wrong!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>何かが変です！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The input is updating very slowly.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>入力欄の更新が非常に遅くなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We've fixed the first problem (suspending outside of a transition).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>元の問題（トランジション外でサスペンドが起こる）は解決しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But now because of the transition, our state doesn't update immediately, and it can't "drive" a controlled input!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>が、このトランジションのせいで、state がすぐに更新されず、制御された入力欄を「駆動」することができなくなってしまいました！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The answer to this problem **is to split the state in two parts:** a "high priority" part that updates immediately, and a "low priority" part that may wait for a transition.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この問題の答えは、**state を 2 つに分割して**、即座に更新される「高優先度」の部分と、トランジションを待つことのできる「低優先度」の部分に分けることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In our example, we already have two state variables.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>我々の例には、すでに 2 つの state 変数があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The input text is in `query`, and we read the translation from `resource`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>入力中のテキストは `query` に入っており、翻訳結果は `resource` から読み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We want changes to the `query` state to happen immediately, but changes to the `resource` (i.e. fetching a new translation) should trigger a transition.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`query` state の更新は即座に反映される一方で、`resource` の更新（つまり新しい翻訳結果の取得）はトランジションを開始する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>So the correct fix is to put `setQuery` (which doesn't suspend) *outside* the transition, but `setResource` (which will suspend) *inside* of it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>従って正しい修正方法は `setQuery`（サスペンドしない）をトランジションの*外部*に持っていき、`setResource`（サスペンドする）を*内部*に持っていくことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/lively-smoke-fdf93)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/lively-smoke-fdf93)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With this change, it works as expected.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これで期待通りに動作するようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can type into the input immediately, and the translation later "catches up" to what we have typed.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>入力欄には即座にタイプでき、トランジションはタイプした内容にいずれ「追いつく」ようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Deferring a Value {#deferring-a-value}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>### 値の遅延 {#deferring-a-value}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, React always renders a consistent UI.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>デフォルトでは React は常に整合性のある UI を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Consider code like this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>以下のようなコードを考えましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React guarantees that whenever we look at these components on the screen, they will reflect data from the same `user`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>React は、これらのコンポーネントを画面上でどんなタイミングで見ても、同じ `user` からのデータが反映されていることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a different `user` is passed down because of a state update, you would see them changing together.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>state の更新によって別の `user` が渡された場合、両方が同時に変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can't ever record a screen and find a frame where they would show values from different `user`s. (If you ever run into a case like this, file a bug!)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>画面を録画しても、別の `user` からの値が表示されているということはただの 1 フレームすらあり得ません（万一こんなことがあったらバグを登録してください！）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This makes sense in the vast majority of situations.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは大多数の状況では理にかなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inconsistent UI is confusing and can mislead users. (For example, it would be terrible if a messenger's Send button and the conversation picker pane "disagreed" about which thread is currently selected.)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>UI の不整合は混乱を招き、ユーザを欺くことになります（例えば、メッセンジャーの「送信」ボタンと会話選択ペインとが合致せず、どのスレッドが現在選択されているか分からなくなったら最悪です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, sometimes it might be helpful to intentionally introduce an inconsistency.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし、意図的に不整合性を導入することが有用であることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We could do it manually by "splitting" the state like above, but React also offers a built-in Hook for this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは上記のように state を手動で「分割」することでも行えますが、React はこのための組み込みフックも提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To demonstrate this feature, we'll use [the profile switcher example](https://codesandbox.io/s/musing-ramanujan-bgw2o).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この機能をデモするために[プロフィール切り替えの例](https://codesandbox.io/s/musing-ramanujan-bgw2o)を使いましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Click the "Next" button and notice how it takes 1 second to do a transition.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>"Next" ボタンをクリックして、トランジションに 1 秒かかることを確かめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's say that fetching the user details is very fast and only takes 300 milliseconds.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>仮に、ユーザ詳細の取得は非常に高速で、300 ミリ秒しかかからないとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Currently, we're waiting a whole second because we need both user details and posts to display a consistent profile page.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>現在のところ、一貫性のあるプロフィールページを表示するにはユーザ詳細と投稿の両方が必要なので、まるまる 1 秒間待機しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But what if we want to show the details faster?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ユーザ詳細だけ早めに表示したい場合はどうしたらいいのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If we're willing to sacrifice consistency, we could **pass potentially stale data to the components that delay our transition**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>一貫性を犠牲にしても構わないのであれば、**トランジションを遅延させているコンポーネントに古くなっているかもしれない値を渡す**ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That's what `useDeferredValue()` lets us do:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これが `useDeferredValue()` によって可能になることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/vigorous-keller-3ed2b)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/vigorous-keller-3ed2b)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The tradeoff we're making here is that `&lt;ProfileTimeline&gt;` will be inconsistent with other components and potentially show an older item.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ここで生まれたトレードオフは、`&lt;ProfileTimeline&gt;` は他のコンポーネントとの整合性が保たれず、古いアイテムを表示するかもしれない、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Click "Next" a few times, and you'll notice it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>"Next" を何度かクリックすると分かるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But thanks to that, we were able to cut down the transition time from 1000ms to 300ms.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかしこのお陰で、トランジションにかかる時間が 1000ms から 300ms になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whether or not it's an appropriate tradeoff depends on the situation.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これが適切なトレードオフなのかどうかは状況によります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But it's a handy tool, especially when the content doesn't change noticeably between items, and the user might not even realize they were looking at a stale version for a second.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかしこれは有用なツールであり、特にコンテンツの変化があまり目立たず、ユーザが古い情報を一瞬見ていることに気付きすらしないような場合には有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's worth noting that `useDeferredValue` is not *only* useful for data fetching.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`useDeferredValue` はデータ取得のときに*のみ*有用であるというわけではない、ということを知っておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは高価な計算が必要なコンポーネントツリーがユーザ操作（テキスト入力へのタイピングなど）を遅くしている場合にも有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Just like we can "defer" a value that takes too long to fetch (and show its old value despite other components updating), we can do this with trees that take too long to render.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>取得するのに時間のかかりすぎる値を「遅延」できる（そして他のコンポーネントが更新されているにも関わらず古い値を表示できる）のと全く同様に、レンダーに時間のかかりすぎるツリーに対しても同じことが行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider a filterable list like this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>例えば以下のようなフィルタ可能なリストを考えてみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/pensive-shirley-wkp46)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/pensive-shirley-wkp46)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, **every item in `&lt;MySlowList&gt;` has an artificial slowdown -- each of them blocks the thread for a few milliseconds**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この例では、**`&lt;MySlowList&gt;` 内のすべての要素に人為的な遅延を作っています -- すべての要素がスレッドを数 ms ずつブロックしているのです**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'd never do this in a real app, but this helps us simulate what can happen in a deep component tree with no single obvious place to optimize.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>現実のアプリケーションでこんなことは絶対にやりませんが、深いコンポーネントツリーがあって単一の最適化可能部位が明確には存在しない場合に起こることをシミュレートできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can see how typing in the input causes stutter.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>入力欄にタイプすると引っかかりが発生していることが分かるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now let's add `useDeferredValue`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>では `useDeferredValue` を加えましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/infallible-dewdney-9fkv9)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/infallible-dewdney-9fkv9)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now typing has a lot less stutter -- although we pay for this by showing the results with a lag.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これでタイピングした際の引っかかりは大幅に軽減されました -- ただし結果の表示に遅延が生じることと引き替えに、です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How is this different from debouncing?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これはデバウンス (debounce) とどう異なるのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our example has a fixed artificial delay (3ms for every one of 80 items), so there is always a delay, no matter how fast our computer is.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>我々の例では人為的な固定の遅延時間（80 個の要素それぞれに 3 ms）があるため、どんなにコンピュータが高速でも必ず遅延が発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the `useDeferredValue` value only "lags behind" if the rendering takes a while.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>しかし `useDeferredValue` の値は、レンダーに時間がかかっている場合にのみ「遅れ」が生じるのです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is no minimal lag imposed by React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>React によって最低これだけラグが生じると決められているわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With a more realistic workload, you can expect the lag to adjust to the user’s device.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>より現実的なワークロードでは、ユーザのデバイスによってラグの適応が起こることが期待できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On fast machines, the lag would be smaller or non-existent, and on slow machines, it would be more noticeable.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>高速なマシンではラグは小さいか存在しなくなり、遅いマシンではラグはより目立つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, the app would remain responsive.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>どちらのケースでも、アプリケーションはレスポンシブに保たれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That’s the advantage of this mechanism over debouncing or throttling, which always impose a minimal delay and can't avoid blocking the thread while rendering.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>デバウンスやスロットル (throttle) では常に少々の遅延が発生し、レンダー中にスレッドがブロックされることを防げませんので、これが本メカニズムの利点ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though there is an improvement in responsiveness, this example isn't as compelling yet because Concurrent Mode is missing some crucial optimizations for this use case.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>レスポンシブ性という点で改善点は得られましたが、並列モードにはこのユースケースにおける重要な最適化のいくつかが欠けており、そのため今回の例はそれほど魅力的ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Still, it is interesting to see that features like `useDeferredValue` (or `useTransition`) are useful regardless of whether we're waiting for network or for computational work to finish.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>それでも、`useDeferredValue`（や `useTransition`）のような機能が、ネットワークの完了を待機しているのか計算の完了を待機しているのかに関わらず有用である、というのは興味深い事実です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>`&lt;SuspenseList&gt;` is the last pattern that's related to orchestrating loading states.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`&lt;SuspenseList&gt;` が、ローディング中状態の制御に関する最後のパターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Consider this example:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>以下の例を考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/proud-tree-exg5t)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/proud-tree-exg5t)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The API call duration in this example is randomized.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この例での API のコール時間はランダム化されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you keep refreshing it, you will notice that sometimes the posts arrive first, and sometimes the "fun facts" arrive first.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>再読み込みを繰り返すと、タイムライン投稿が先に来ることもあれば「豆知識」が先に来る場合もあることに気付くでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This presents a problem.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>ここで問題が起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the response for fun facts arrives first, we'll see the fun facts below the `<bpt i="2" x="2">&lt;h2&gt;</bpt>Loading posts...<ept i="2">&lt;/h2&gt;</ept>` fallback for posts.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>もし豆知識のレスポンスが先に来た場合、`<bpt i="2" x="2">&lt;h2&gt;</bpt>Loading posts...<ept i="2">&lt;/h2&gt;</ept>` というフォールバックの下方に豆知識が表示されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We might start reading them, but then the *posts* response will come back, and shift all the facts down.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>豆知識を読み始めた瞬間に*投稿の*レスポンスが返ってきて、豆知識が下側にずれてしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is jarring.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは煩わしいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One way we could fix it is by putting them both in a single boundary:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これを修正する 1 つの方法は、両方を単一のバウンダリに入れることです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/currying-violet-5jsiy)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/currying-violet-5jsiy)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The problem with this is that now we *always* wait for both of them to be fetched.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>この方法の問題は、*常に*両方が取得されるまで待つようになったことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if it's the *posts* that came back first, there's no reason to delay showing them.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>もし*投稿*の方が先に返ってきたなら、それを表示するのを遅らせる理由はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When fun facts load later, they won't shift the layout because they're already below the posts.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>豆知識が後で返ってきても、それは既に投稿の下側にあるのですから、レイアウトのずれを発生させません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other approaches to this, such as composing Promises in a special way, are increasingly difficult to pull off when the loading states are located in different components down the tree.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>Promise を特殊な方法で合成するといった、この問題に対する他のアプローチは、ツリー内の様々なコンポーネントにロード中状態が存在するようになると徐々にうまく行かなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To solve this, we will import `SuspenseList`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これを解決するため、`SuspenseList` をインポートしましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>`&lt;SuspenseList&gt;` coordinates the "reveal order" of the closest `&lt;Suspense&gt;` nodes below it:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`&lt;SuspenseList&gt;` は、配下にある直近の `&lt;Suspense&gt;` ノードの「開放順序」を制御します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**[Try it on CodeSandbox](https://codesandbox.io/s/black-wind-byilt)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>**[CodeSandbox で試す](https://codesandbox.io/s/black-wind-byilt)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The `revealOrder="forwards"` option means that the closest `&lt;Suspense&gt;` nodes inside this list **will only "reveal" their content in the order they appear in the tree -- even if the data for them arrives in a different order**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`revealOrder="forwards"` というオプションは、このリスト内部にある直近の `&lt;Suspense&gt;` ノードは、**データが異なった順番で到着した場合でも、ツリーに現れる順番でしか「開放」されない**ということを意味します。`&lt;SuspenseList&gt;` には他にも興味深いモードがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>`&lt;SuspenseList&gt;` has other interesting modes: try changing `"forwards"` to `"backwards"` or `"together"` and see what happens.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`"forwards"` を `"backwards"` や `"together"` に変えてみて、何が起こるか確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can control how many loading states are visible at once with the `tail` prop.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`tail` プロパティを使って同時に表示されるローディング中状態の数を制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If we specify `tail="collapsed"`, we'll see *at most one* fallback at a time.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>`tail="collapsed"` と指定すると、同時に*最大でも 1 つ*しかフォールバックが表示されないようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can play with it [here](https://codesandbox.io/s/adoring-almeida-1zzjh).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>[こちら](https://codesandbox.io/s/adoring-almeida-1zzjh)で試すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keep in mind that `&lt;SuspenseList&gt;` is composable, like anything in React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>React の他のあらゆるものと同様に、`&lt;SuspenseList&gt;` は合成可能であることを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can create a grid by putting several `&lt;SuspenseList&gt;` rows inside a `&lt;SuspenseList&gt;` table.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>例えば、`&lt;SuspenseList&gt;` の行を `&lt;SuspenseList&gt;` のテーブル内に入れてグリッドを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Next Steps {#next-steps}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>## 次のステップ {#next-steps}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Concurrent Mode offers a powerful UI programming model and a set of new composable primitives to help you orchestrate delightful user experiences.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>並列モードは、快適なユーザ体験を組み上げるためのパワフルな UI プログラミングモデルと、合成可能な新たな基本要素群を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's a result of several years of research and development, but it's not finished.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>これは数年にわたる研究と開発の成果ですが、まだ完成していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the section on [adopting Concurrent Mode](/docs/concurrent-mode-adoption.html), we'll describe how you can try it and what you can expect.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T043349Z">
        <seg>[並列モードの利用開始](/docs/concurrent-mode-adoption.html)についてのセクションで、並列モードを試す方法や期待されることについて解説します。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
