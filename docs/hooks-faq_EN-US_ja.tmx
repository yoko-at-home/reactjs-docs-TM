<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.3.2_0_6a661c5e0" segtype="sentence" srclang="EN-US"/>
  <body>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>---
id: hooks-faq
title: Hooks FAQ
permalink: docs/hooks-faq.html
prev: hooks-reference.html
---</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>---
id: hooks-faq
title: フックに関するよくある質問
permalink: docs/hooks-faq.html
prev: hooks-reference.html
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>*Hooks* are a new addition in React 16.8.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>*フック (hook)* は React 16.8 で追加された新機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They let you use state and other React features without writing a class.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>state などの React の機能を、クラスを書かずに使えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This page answers some of the frequently asked questions about [Hooks](/docs/hooks-overview.html).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>このページでは[フック](/docs/hooks-overview.html)に関するよくある質問にいくつかお答えします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **[Adoption Strategy](#adoption-strategy)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* **[導入の指針](#adoption-strategy)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Which versions of React include Hooks?](#which-versions-of-react-include-hooks)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [フックが使える React のバージョンはどれですか？](#which-versions-of-react-include-hooks)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Do I need to rewrite all my class components?](#do-i-need-to-rewrite-all-my-class-components)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [クラスコンポーネントを全部書き換える必要があるのですか？](#do-i-need-to-rewrite-all-my-class-components)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [What can I do with Hooks that I couldn't with classes?](#what-can-i-do-with-hooks-that-i-couldnt-with-classes)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [クラスではできず、フックでできるようになることは何ですか？](#what-can-i-do-with-hooks-that-i-couldnt-with-classes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How much of my React knowledge stays relevant?](#how-much-of-my-react-knowledge-stays-relevant)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [これまでの React の知識はどの程度使えますか？](#how-much-of-my-react-knowledge-stays-relevant)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Should I use Hooks, classes, or a mix of both?](#should-i-use-hooks-classes-or-a-mix-of-both)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [フック、クラスのいずれを使うべきですか、あるいはその両方でしょうか？](#should-i-use-hooks-classes-or-a-mix-of-both)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Do Hooks cover all use cases for classes?](#do-hooks-cover-all-use-cases-for-classes)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [フックはクラスのユースケースのすべてをカバーしていますか？](#do-hooks-cover-all-use-cases-for-classes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Do Hooks replace render props and higher-order components?](#do-hooks-replace-render-props-and-higher-order-components)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [フックはレンダープロップや高階コンポーネントを置き換えるものですか？](#do-hooks-replace-render-props-and-higher-order-components)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [What do Hooks mean for popular APIs like Redux connect() and React Router?](#what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [Redux の connect() や React Router といった人気の API はフックによりどうなりますか？](#what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Do Hooks work with static typing?](#do-hooks-work-with-static-typing)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [フックは静的型付けと組み合わせてうまく動きますか？](#do-hooks-work-with-static-typing)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How to test components that use Hooks?](#how-to-test-components-that-use-hooks)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [フックを使ったコンポーネントはどのようにテストするのですか？](#how-to-test-components-that-use-hooks)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [What exactly do the lint rules enforce?](#what-exactly-do-the-lint-rules-enforce)
* **[From Classes to Hooks](#from-classes-to-hooks)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [Lint ルールは具体的に何を強制するのですか？](#what-exactly-do-the-lint-rules-enforce)
* **[クラスからフックへ](#from-classes-to-hooks)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How do lifecycle methods correspond to Hooks?](#how-do-lifecycle-methods-correspond-to-hooks)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [個々のライフサイクルメソッドはフックとどのように対応するのですか？](#how-do-lifecycle-methods-correspond-to-hooks)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How can I do data fetching with Hooks?](#how-can-i-do-data-fetching-with-hooks)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [フックでデータの取得をどのように行うのですか？](#how-can-i-do-data-fetching-with-hooks)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Is there something like instance variables?](#is-there-something-like-instance-variables)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [インスタンス変数のようなものはありますか？](#is-there-something-like-instance-variables)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Should I use one or many state variables?](#should-i-use-one-or-many-state-variables)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [state 変数は 1 つにすべきですか、たくさん使うべきですか？](#should-i-use-one-or-many-state-variables)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Can I run an effect only on updates?](#can-i-run-an-effect-only-on-updates)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [コンポーネントの更新のときだけ副作用を実行することは可能ですか？](#can-i-run-an-effect-only-on-updates)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How to get the previous props or state?](#how-to-get-the-previous-props-or-state)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [前回の props や state はどうすれば取得できますか？](#how-to-get-the-previous-props-or-state)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Why am I seeing stale props or state inside my function?](#why-am-i-seeing-stale-props-or-state-inside-my-function)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [関数内で古い props や state が見えているのはなぜですか？](#why-am-i-seeing-stale-props-or-state-inside-my-function)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How do I implement getDerivedStateFromProps?](#how-do-i-implement-getderivedstatefromprops)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [どうすれば getDerivedStateFromProps を実装できますか？](#how-do-i-implement-getderivedstatefromprops)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Is there something like forceUpdate?](#is-there-something-like-forceupdate)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [forceUpdate のようなものはありますか？](#is-there-something-like-forceupdate)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Can I make a ref to a function component?](#can-i-make-a-ref-to-a-function-component)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [関数コンポーネントへの ref を作ることは可能ですか？](#can-i-make-a-ref-to-a-function-component)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How can I measure a DOM node?](#how-can-i-measure-a-dom-node)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [DOM ノードの位置やサイズの測定はどのように行うのですか？](#how-can-i-measure-a-dom-node)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [What does const [thing, setThing] = useState() mean?](#what-does-const-thing-setthing--usestate-mean)
* **[Performance Optimizations](#performance-optimizations)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [const [thing, setThing] = useState() というのはどういう意味ですか？](#what-does-const-thing-setthing--usestate-mean)
* **[パフォーマンス最適化](#performance-optimizations)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Can I skip an effect on updates?](#can-i-skip-an-effect-on-updates)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [更新時に副作用をスキップすることはできますか？](#can-i-skip-an-effect-on-updates)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Is it safe to omit functions from the list of dependencies?](#is-it-safe-to-omit-functions-from-the-list-of-dependencies)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [依存の配列から関数を省略しても大丈夫ですか？](#is-it-safe-to-omit-functions-from-the-list-of-dependencies)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [What can I do if my effect dependencies change too often?](#what-can-i-do-if-my-effect-dependencies-change-too-often)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [副作用の依存リストが頻繁に変わりすぎる場合はどうすればよいですか？](#what-can-i-do-if-my-effect-dependencies-change-too-often)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How do I implement shouldComponentUpdate?](#how-do-i-implement-shouldcomponentupdate)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [どうすれば `shouldComponentUpdate` を実装できますか？](#how-do-i-implement-shouldcomponentupdate)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How to memoize calculations?](#how-to-memoize-calculations)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [計算結果のメモ化はどのように行うのですか？](#how-to-memoize-calculations)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How to create expensive objects lazily?](#how-to-create-expensive-objects-lazily)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [計算量の大きいオブジェクトの作成を遅延する方法はありますか？](#how-to-create-expensive-objects-lazily)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Are Hooks slow because of creating functions in render?](#are-hooks-slow-because-of-creating-functions-in-render)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [レンダー内で関数を作るせいでフックは遅くなるのではないですか？](#are-hooks-slow-because-of-creating-functions-in-render)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How to avoid passing callbacks down?](#how-to-avoid-passing-callbacks-down)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [どうすれば複数のコールバックを深く受け渡すのを回避できますか？](#how-to-avoid-passing-callbacks-down)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How to read an often-changing value from useCallback?](#how-to-read-an-often-changing-value-from-usecallback)
* **[Under the Hood](#under-the-hood)**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [useCallback からの頻繁に変わる値を読み出す方法は？](#how-to-read-an-often-changing-value-from-usecallback)
* **[内部の仕組み](#under-the-hood)**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [How does React associate Hook calls with components?](#how-does-react-associate-hook-calls-with-components)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [React はフック呼び出しとコンポーネントとをどのように関連付けているのですか？](#how-does-react-associate-hook-calls-with-components)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [What is the prior art for Hooks?](#what-is-the-prior-art-for-hooks)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [フックの先行技術にはどのようなものがありますか？](#what-is-the-prior-art-for-hooks)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Adoption Strategy {#adoption-strategy}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>## 導入の指針 {#adoption-strategy}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Which versions of React include Hooks?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### フックが使える React のバージョンはどれですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Starting with 16.8.0, React includes a stable implementation of React Hooks for:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React バージョン 16.8.0 より、以下においてフックの安定版の実装が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that **to enable Hooks, all React packages need to be 16.8.0 or higher**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>**フックを利用するには、すべての React のパッケージが 16.8.0 以上である必要があります**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hooks won't work if you forget to update, for example, React DOM.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>例えば React DOM の更新を忘れた場合、フックは動作しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>[React Native 0.59](https://reactnative.dev/blog/2019/03/12/releasing-react-native-059) and above support Hooks.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React Native は[バージョン 0.59](https://reactnative.dev/blog/2019/03/12/releasing-react-native-059) 以降でフックをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Do I need to rewrite all my class components?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### クラスコンポーネントを全部書き換える必要があるのですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>いいえ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are [no plans](/docs/hooks-intro.html#gradual-adoption-strategy) to remove classes from React -- we all need to keep shipping products and can't afford rewrites.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React からクラスを削除する[予定はありません](/docs/hooks-intro.html#gradual-adoption-strategy) -- 我々はみなプロダクトを世に出し続ける必要があり、クラスを書き換えている余裕はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We recommend trying Hooks in new code.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>新しいコードでフックを試すことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### What can I do with Hooks that I couldn't with classes?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### クラスではできず、フックでできるようになることは何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hooks offer a powerful and expressive new way to reuse functionality between components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フックにより、コンポーネント間で機能を再利用するためのパワフルで表現力の高い手段が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>["Building Your Own Hooks"](/docs/hooks-custom.html) provides a glimpse of what's possible.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>["独自フックの作成"](/docs/hooks-custom.html)を読めばできることの概要が掴めるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>[This article](https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889) by a React core team member dives deeper into the new capabilities unlocked by Hooks.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React のコアチームメンバーによって書かれた[この記事](https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889)により、フックによって新たにもたらされる可能性についての洞察が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How much of my React knowledge stays relevant?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### これまでの React の知識はどの程度使えますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hooks are a more direct way to use the React features you already know -- such as state, lifecycle, context, and refs.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フックとは、state やライフサイクル、コンテクストや ref といった、あなたが既に知っている React の機能をより直接的に利用できるようにする手段です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They don't fundamentally change how React works, and your knowledge of components, props, and top-down data flow is just as relevant.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React の動作が根本的に変わるようなものではありませんし、コンポーネントや props、トップダウンのデータの流れについての知識はこれまでと同様に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hooks do have a learning curve of their own.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>もちろんフックにはフックなりの学習曲線があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there's something missing in this documentation, [raise an issue](https://github.com/reactjs/reactjs.org/issues/new) and we'll try to help.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>このドキュメントに足りないことを見つけたら [Issue を報告](https://github.com/reactjs/reactjs.org/issues/new)していただければ、お手伝いします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Should I use Hooks, classes, or a mix of both?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### フック、クラスのいずれを使うべきですか、あるいはその両方でしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you're ready, we'd encourage you to start trying Hooks in new components you write.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>準備ができしだい、新しいコンポーネントでフックを試すことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Make sure everyone on your team is on board with using them and familiar with this documentation.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>チームの全員の準備が完了し、このドキュメントに馴染んでいることを確かめましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We don't recommend rewriting your existing classes to Hooks unless you planned to rewrite them anyway (e.g. to fix bugs).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>（例えばバグを直すなどの理由で）何にせよ書き換える予定の場合を除いては、既存のクラスをフックに書き換えることはお勧めしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can't use Hooks *inside* a class component, but you can definitely mix classes and function components with Hooks in a single tree.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>クラスコンポーネントの*定義内で*フックを使うことはできませんが、クラス型コンポーネントとフックを使った関数コンポーネントとを 1 つのコンポーネントツリー内で混在させることは全く問題ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whether a component is a class or a function that uses Hooks is an implementation detail of that component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>あるコンポーネントがクラスで書かれているかフックを用いた関数で書かれているかというのは、そのコンポーネントの実装の詳細です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the longer term, we expect Hooks to be the primary way people write React components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>長期的には、フックが React のコンポーネントを書く際の第一選択となることを期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Do Hooks cover all use cases for classes?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### フックはクラスのユースケースのすべてをカバーしていますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our goal is for Hooks to cover all use cases for classes as soon as possible.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>我々の目標はできるだけ早急にフックがすべてのクラスのユースケースをカバーできるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are no Hook equivalents to the uncommon `getSnapshotBeforeUpdate`, `getDerivedStateFromError` and `componentDidCatch` lifecycles yet, but we plan to add them soon.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>まだ使用頻度の低い `getSnapshotBeforeUpdate`、`getDerivedStateFromError` および `componentDidCatch` についてはフックでの同等物が存在していませんが、すぐに追加する予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is an early time for Hooks, and some third-party libraries might not be compatible with Hooks at the moment.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>まだフックはできたばかりですので、幾つかのサードパーティ製のライブラリは現時点でフックとの互換性がないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Do Hooks replace render props and higher-order components?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### フックはレンダープロップや高階コンポーネントを置き換えるものですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Often, render props and higher-order components render only a single child.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>レンダープロップや高階コンポーネントは、ひとつの子だけをレンダーすることがよくあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We think Hooks are a simpler way to serve this use case.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フックはこのようなユースケースを実現するより簡単な手段だと考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is still a place for both patterns (for example, a virtual scroller component might have a `renderItem` prop, or a visual container component might have its own DOM structure).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これらのパターンには引き続き利用すべき場面があります（例えば、バーチャルスクローラーコンポーネントは `renderItem` プロパティを持つでしょうし、コンテナコンポーネントは自分自身の DOM 構造を有しているでしょう）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But in most cases, Hooks will be sufficient and can help reduce nesting in your tree.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>とはいえ大抵の場合ではフックで十分であり、フックがツリーのネストを減らすのに役立つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### What do Hooks mean for popular APIs like Redux `connect()` and React Router?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### Redux の `connect()` や React Router といった人気の API はフックによりどうなりますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can continue to use the exact same APIs as you always have; they'll continue to work.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これまでと同様に全く同じ API を使用し続けることができます。それらは動作し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React Redux since v7.1.0 [supports Hooks API](https://react-redux.js.org/api/hooks) and exposes hooks like `useDispatch` or `useSelector`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React Redux は v7.1.0 より [フック API をサポート](https://react-redux.js.org/api/hooks)しており、`useDispatch` や `useSelector` といったフックを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React Router [supports hooks](https://reacttraining.com/react-router/web/api/Hooks) since v5.1.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React Router は v5.1 より [フック API をサポート](https://reacttraining.com/react-router/web/api/Hooks) しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other libraries might support hooks in the future too.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>他のライブラリも、将来的にフックをサポートするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Do Hooks work with static typing?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### フックは静的型付けと組み合わせてうまく動きますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hooks were designed with static typing in mind.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フックは静的型付けを念頭に設計されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because they're functions, they are easier to type correctly than patterns like higher-order components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フックは関数ですので、高階コンポーネントのようなパターンと比較しても正しく型付けするのは容易です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The latest Flow and TypeScript React definitions include support for React Hooks.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>最新版の Flow と TypeScript における React の型定義には、React のフックについてのサポートが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Importantly, custom Hooks give you the power to constrain React API if you'd like to type them more strictly in some way.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>重要なことですが、もしより厳密に型付けしたい場合は、カスタムフックを使うことで React API に何らかの制約を加えることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React gives you the primitives, but you can combine them in different ways than what we provide out of the box.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React は基本部品を提供しますが、最初から提供されているものと違う方法でそれらを様々に組み合わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How to test components that use Hooks?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### フックを使ったコンポーネントはどのようにテストするのですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>From React's point of view, a component using Hooks is just a regular component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React の観点から見れば、フックを使ったコンポーネントは単なる普通のコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your testing solution doesn't rely on React internals, testing components with Hooks shouldn't be different from how you normally test components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>あなたのテストソリューションが React の内部動作に依存しているのでない場合、フックを使ったコンポーネントのテストのやり方は、あなたが普段コンポーネントをテストしているやり方と変わらないはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;Note
&gt;
&gt;[Testing Recipes](/docs/testing-recipes.html) include many examples that you can copy and paste.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>&gt; 補足
&gt;
&gt; [テストのレシピ集](/docs/testing-recipes.html)にコピー・ペーストで使えるたくさんの例が掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, let's say we have this counter component:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>例えばこのようなカウンタコンポーネントがあるとしましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll test it using React DOM. To make sure that the behavior matches what happens in the browser, we'll wrap the code rendering and updating it into [`ReactTestUtils.act()`](/docs/test-utils.html#act) calls:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これを React DOM を使ってテストします。ブラウザでの挙動と確実に合致させるため、これをレンダーしたり更新したりするコードを [`ReactTestUtils.act()`](/docs/test-utils.html#act) でラップします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The calls to `act()` will also flush the effects inside of them.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`act()` を呼び出すと内部の副作用も処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to test a custom Hook, you can do so by creating a component in your test, and using your Hook from it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>カスタムフックをテストしたい場合は、テスト内でコンポーネントを作って中でそのカスタムフックを使うようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Then you can test the component you wrote.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>そうすればそのコンポーネントをテストできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To reduce the boilerplate, we recommend using [React Testing Library](https://testing-library.com/react) which is designed to encourage writing tests that use your components as the end users do.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>ボイラープレートを減らすため、エンドユーザが使うのと同じ形でコンポーネントを使ってテストが記述できるように設計されている、[React Testing Library](https://testing-library.com/react) の利用をお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, check out [Testing Recipes](/docs/testing-recipes.html).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>詳細については、[テストのレシピ集](/docs/testing-recipes.html)をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### What exactly do the [lint rules](https://www.npmjs.com/package/eslint-plugin-react-hooks) enforce?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### [Lint ルール](https://www.npmjs.com/package/eslint-plugin-react-hooks)は具体的に何を強制するのですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We provide an [ESLint plugin](https://www.npmjs.com/package/eslint-plugin-react-hooks) that enforces [rules of Hooks](/docs/hooks-rules.html) to avoid bugs.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>我々は [ESLint プラグイン](https://www.npmjs.com/package/eslint-plugin-react-hooks)を提供しており、これにより[フックのルール](/docs/hooks-rules.html)を強制してバグを減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It assumes that any function starting with "`use`" and a capital letter right after it is a Hook.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>このルールは、`use` で始まり大文字が続くような名前の関数はすべてフックであると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We recognize this heuristic isn't perfect and there may be some false positives, but without an ecosystem-wide convention there is just no way to make Hooks work well -- and longer names will discourage people from either adopting Hooks or following the convention.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これは不完全な推測手段であり過剰検出があるかもしれないことは認識していますが、エコシステム全体での規約なくしてはフックはうまく動作しません。また名前を長くするとフックを利用したり規約を守ったりしてくれなくなるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the rule enforces that:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>具体的には、このルールは以下を強制します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Calls to Hooks are either inside a `PascalCase` function (assumed to be a component) or another `useSomething` function (assumed to be a custom Hook).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* フックの呼び出しが `PascalCase` 名の関数内（コンポーネントと見なされます）か、あるいは他の `useSomething` 式の名前の関数内（カスタムフックと見なされます）にあること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Hooks are called in the same order on every render.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* すべてのレンダー間でフックが同じ順番で呼び出されること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are a few more heuristics, and they might change over time as we fine-tune the rule to balance finding bugs with avoiding false positives.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これ以外にも幾つかの推測を行っており、また、バグ検出と過剰検出抑制とのバランスを調整していくなかで、これらは将来的に変わる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## From Classes to Hooks {#from-classes-to-hooks}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>## クラスからフックへ {#from-classes-to-hooks}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How do lifecycle methods correspond to Hooks?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### 個々のライフサイクルメソッドはフックとどのように対応するのですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* `constructor`: Function components don't need a constructor.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* `constructor`: 関数コンポーネントはコンストラクタを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can initialize the state in the [`useState`](/docs/hooks-reference.html#usestate) call.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>state は [`useState`](/docs/hooks-reference.html#usestate) を呼び出すときに初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If computing the initial state is expensive, you can pass a function to `useState`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>初期 state の計算が高価である場合、`useState` に関数を渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* `getDerivedStateFromProps`: Schedule an update [while rendering](#how-do-i-implement-getderivedstatefromprops) instead.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* `getDerivedStateFromProps`: [レンダー中に](#how-do-i-implement-getderivedstatefromprops)更新をスケジューリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* `shouldComponentUpdate`: See `React.memo` [below](#how-do-i-implement-shouldcomponentupdate).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* `shouldComponentUpdate`: ページ[下部の](#how-do-i-implement-shouldcomponentupdate) `React.memo` についての説明を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* `render`: This is the function component body itself.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* `render`: これは関数コンポーネントの本体そのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`: The [`useEffect` Hook](/docs/hooks-reference.html#useeffect) can express all combinations of these (including [less](#can-i-skip-an-effect-on-updates) [common](#can-i-run-an-effect-only-on-updates) cases).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`: これらのあらゆる組み合わせは [`useEffect` フック](/docs/hooks-reference.html#useeffect)で表現できます（[これ](#can-i-skip-an-effect-on-updates)や[これ](#can-i-run-an-effect-only-on-updates)のような頻度の低いケースも含め）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* `getSnapshotBeforeUpdate`, `componentDidCatch` and `getDerivedStateFromError`: There are no Hook equivalents for these methods yet, but they will be added soon.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* `getSnapshotBeforeUpdate`、`componentDidCatch` および `getDerivedStateFromError`: フックによる同等物はまだ存在していませんが、近日中に追加される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How can I do data fetching with Hooks?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### フックでデータの取得をどのように行うのですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here is a [small demo](https://codesandbox.io/s/jvvkoo8pq3) to get you started.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>まずはこちらの[小さなデモ](https://codesandbox.io/s/jvvkoo8pq3)をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To learn more, check out [this article](https://www.robinwieruch.de/react-hooks-fetch-data/) about data fetching with Hooks.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フックを使ってデータの取得をする方法について詳しく学ぶには[こちらの記事](https://www.robinwieruch.de/react-hooks-fetch-data/)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Is there something like instance variables?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### インスタンス変数のようなものはありますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Yes!</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>はい！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The [`useRef()`](/docs/hooks-reference.html#useref) Hook isn't just for DOM refs.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>[`useRef()`](/docs/hooks-reference.html#useref) フックは DOM への参照を保持するためだけにあるのではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The "ref" object is a generic container whose `current` property is mutable and can hold any value, similar to an instance property on a class.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>"ref" オブジェクトは汎用のコンテナであり、その `current` プロパティの値は書き換え可能かつどのような値でも保持することができますので、クラスのインスタンス変数と同様に利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can write to it from inside `useEffect`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>例えば `useEffect` 内から "ref" オブジェクトを書き換えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If we just wanted to set an interval, we wouldn't need the ref (`id` could be local to the effect), but it's useful if we want to clear the interval from an event handler:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>単にインターバルをセットしたいだけであれば（`id` はこの副作用内でローカルでよいので）この ref は必要ないところですが、もしもイベントハンドラ内でインターバルをクリアしたい場合には便利です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conceptually, you can think of refs as similar to instance variables in a class.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>概念的には、ref はクラスにおけるインスタンス変数と似たものだと考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless you're doing [lazy initialization](#how-to-create-expensive-objects-lazily), avoid setting refs during rendering -- this can lead to surprising behavior.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>[遅延初期化](#how-to-create-expensive-objects-lazily)をしたい場合を除き、レンダーの最中に ref を書き換えることはしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, typically you want to modify refs in event handlers and effects.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>その代わり、通常 ref はイベントハンドラや副作用内でだけ書き換えるようにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Should I use one or many state variables?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### state 変数は 1 つにすべきですか、たくさん使うべきですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're coming from classes, you might be tempted to always call `useState()` once and put all state into a single object.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これまでクラスを使っていたなら、`useState()` を 1 回だけ呼んで、1 つのオブジェクト内にすべての state を入れたくなるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can do it if you'd like.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>そうしたければそのようにすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here is an example of a component that follows the mouse movement.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>以下はマウスの動作を追跡するコンポーネントの例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We keep its position and size in the local state:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>位置やサイズの情報を 1 つのローカル state に保持しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now let's say we want to write some logic that changes `left` and `top` when the user moves their mouse.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>ここで例えば、ユーザがマウスを動かしたときに `left` と `top` を変更したいとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note how we have to merge these fields into the previous state object manually:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>この際、これらのフィールドを古い state に手動でマージしないといけないことに注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is because when we update a state variable, we *replace* its value.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これは state 変数を更新する時には変数の値が*置換*されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is different from `this.setState` in a class, which *merges* the updated fields into the object.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これは更新されるフィールドがオブジェクトに*マージ*されるというクラスでの `this.setState` の挙動とは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you miss automatic merging, you could write a custom `useLegacyState` Hook that merges object state updates.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>自動マージがないとつらい場合は、`useLegacyState` のようなカスタムフックを書いてオブジェクト型の state の更新をマージするようにすることはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, **we recommend to split state into multiple state variables based on which values tend to change together.**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>しかし、我々は代わりに、**どの値が一緒に更新されやすいのかに基づいて、state を複数の state 変数に分割することをお勧めします。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, we could split our component state into `position` and `size` objects, and always replace the `position` with no need for merging:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>例えば、コンポーネントの state を `position` と `size` という複数のオブジェクトに分割して、マージを行わなくても `position` を常に新たな値で置換するようにできるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Separating independent state variables also has another benefit.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>互いに独立した state 変数を分割することには別の利点もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It makes it easy to later extract some related logic into a custom Hook, for example:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>そうすることで後からそのロジックをカスタムフックに抽出しやすくなるのです。例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note how we were able to move the `useState` call for the `position` state variable and the related effect into a custom Hook without changing their code.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`position` の state 変数に対する `useState` の呼び出しとそれに関連する副作用を、それらのコードを変えずにカスタムフックに移行できたことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If all state was in a single object, extracting it would be more difficult.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>もしすべての state が単一のオブジェクトに入っていたら、抽出するのはもっと困難だったでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both putting all state in a single `useState` call, and having a `useState` call per each field can work.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>すべての state を 1 つの `useState` 呼び出しに含めても動作しますし、フィールドごとに別に `useState` を持たせることでも動作はします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components tend to be most readable when you find a balance between these two extremes, and group related state into a few independent state variables.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>しかしこれらの両極端の間でうまくバランスを取り、少数の独立した state 変数に関連する state をグループ化することで、コンポーネントは最も読みやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the state logic becomes complex, we recommend [managing it with a reducer](/docs/hooks-reference.html#usereducer) or a custom Hook.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>state のロジックが複雑になった場合は、それを[リデューサで管理する](/docs/hooks-reference.html#usereducer)か、カスタムフックを書くことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Can I run an effect only on updates?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### コンポーネントの更新のときだけ副作用を実行することは可能ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a rare use case.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これは稀なユースケースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need it, you can [use a mutable ref](#is-there-something-like-instance-variables) to manually store a boolean value corresponding to whether you are on the first or a subsequent render, then check that flag in your effect. (If you find yourself doing this often, you could create a custom Hook for it.)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>必要であれば、[変更可能な ref](#is-there-something-like-instance-variables) を使って、初回レンダー中なのか更新中なのかに対応する真偽値を手動で保持し、副作用内でその値を参照するようにすることができます（このようなことを何度もやる場合は、そのためのカスタムフックを書くことができます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How to get the previous props or state?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### 前回の props や state はどうすれば取得できますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Currently, you can do it manually [with a ref](#is-there-something-like-instance-variables):</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>現時点では、これは [ref を使って](#is-there-something-like-instance-variables)手動で行うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This might be a bit convoluted but you can extract it into a custom Hook:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>上記はちょっと複雑かもしれませんが、これをカスタムフックに抽出することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note how this would work for props, state, or any other calculated value.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これは props でも state でも、その他計算されたどのような値に対しても動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's possible that in the future React will provide a `usePrevious` Hook out of the box since it's a relatively common use case.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これは比較的よくあるユースケースですので、将来的に `usePrevious` というフックを React が最初から提供するようにする可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also [the recommended pattern for derived state](#how-do-i-implement-getderivedstatefromprops).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>[派生 state における推奨されるパターン](#how-do-i-implement-getderivedstatefromprops)についても参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Why am I seeing stale props or state inside my function?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### 関数内で古い props や state が見えているのはなぜですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any function inside a component, including event handlers and effects, "sees" the props and state from the render it was created in.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>イベントハンドラにせよ副作用関数にせよ、コンポーネント内に書かれた関数からは、その関数が作成された時の props や state が「見え」ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider code like this:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>以下のような例を考えてみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you first click "Show alert" and then increment the counter, the alert will show the `count` variable **at the time you clicked the "Show alert" button**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>最初に "Show alert" ボタンをクリックして、次にカウンタを増加させた場合、アラートダイアログに表示されるのは **"Show alert" ボタンをクリックした時点での** `count` 変数の値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This prevents bugs caused by the code assuming props and state don't change.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これにより props や state が変わらないことを前提として書かれたコードによるバグが防止できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you intentionally want to read the *latest* state from some asynchronous callback, you could keep it in [a ref](/docs/hooks-faq.html#is-there-something-like-instance-variables), mutate it, and read from it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>非同期的に実行されるコールバック内で、意図的に state の*最新*の値を読み出したいという場合は、その値を [ref](/docs/hooks-faq.html#is-there-something-like-instance-variables) 内に保持して、それを書き換えたり読み出したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, another possible reason you're seeing stale props or state is if you use the "dependency array" optimization but didn't correctly specify all the dependencies.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>最後に、古い props や state が見えている場合に考えられる他の理由は、「依存の配列」による最適化を使った際に正しく依存する値の全部を指定しなかった、というものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if an effect specifies `[]` as the second argument but reads `someProp` inside, it will keep "seeing" the initial value of `someProp`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>例えば副作用フックの第 2 引数に `[]` を指定したにも関わらず副作用内で `someProps` を読み出しているという場合、副作用関数内では `someProps` の初期値がずっと見え続けることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The solution is to either remove the dependency array, or to fix it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>解決方法は依存配列自体を削除するか、配列の中身を修正することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's [how you can deal with functions](#is-it-safe-to-omit-functions-from-the-list-of-dependencies), and here's [other common strategies](#what-can-i-do-if-my-effect-dependencies-change-too-often) to run effects less often without incorrectly skipping dependencies.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>[関数の扱い方](#is-it-safe-to-omit-functions-from-the-list-of-dependencies)、および依存する値の変化を誤って無視することなく副作用の実行回数を減らすための[よくある手法](#what-can-i-do-if-my-effect-dependencies-change-too-often)についてもご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;Note
&gt;
&gt;We provide an [`exhaustive-deps`](https://github.com/facebook/react/issues/14920) ESLint rule as a part of the [`eslint-plugin-react-hooks`](https://www.npmjs.com/package/eslint-plugin-react-hooks#installation) package.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>&gt;補足
&gt;
&gt; [`exhaustive-deps`](https://github.com/facebook/react/issues/14920) という ESLint のルールを [`eslint-plugin-react-hooks`](https://www.npmjs.com/package/eslint-plugin-react-hooks#installation) パッケージの一部として提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It warns when dependencies are specified incorrectly and suggests a fix.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>依存配列が正しく指定されていない場合に警告し、修正を提案します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How do I implement `getDerivedStateFromProps`?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### どうすれば `getDerivedStateFromProps` を実装できますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While you probably [don't need it](/blog/2018/06/07/you-probably-dont-need-derived-state.html), in rare cases that you do (such as implementing a `&lt;Transition&gt;` component), you can update the state right during rendering.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>おそらくそのようなものは[必要ない](/blog/2018/06/07/you-probably-dont-need-derived-state.html)のですが、これが本当に必要になる稀なケースでは（例えば `&lt;Transition&gt;` コンポーネントを実装するときなど）、レンダーの最中に state を更新することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React will re-run the component with updated state immediately after exiting the first render so it wouldn't be expensive.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React は最初のレンダーの終了直後に更新された state を使ってコンポーネントを再実行しますので、計算量は高くなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, we store the previous value of the `row` prop in a state variable so that we can compare:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>以下の例では、`row` プロパティの前回の値を state 変数に格納し後で比較できるようにしています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This might look strange at first, but an update during rendering is exactly what `getDerivedStateFromProps` has always been like conceptually.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これは最初は奇妙に見えるかもしれませんが、これまでも概念的には `getDerivedStateFromProps` はレンダー中に更新を行うというのがまさに目的でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Is there something like forceUpdate?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### forceUpdate のようなものはありますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both `useState` and `useReducer` Hooks [bail out of updates](/docs/hooks-reference.html#bailing-out-of-a-state-update) if the next value is the same as the previous one.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`useState` フックと `useReducer` フックのいずれも、前回と今回で値が同じである場合は[更新を回避](/docs/hooks-reference.html#bailing-out-of-a-state-update)します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mutating state in place and calling `setState` will not cause a re-render.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>適当な場所で state を変化させた後に `setState` を呼び出しても再レンダーは発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Normally, you shouldn't mutate local state in React.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>通常、React でローカル state を直接変更すべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, as an escape hatch, you can use an incrementing counter to force a re-render even if the state has not changed:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>しかし避難ハッチとして、カウンターを使って state が変化していない場合でも再レンダーを強制することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Try to avoid this pattern if possible.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>可能であればこのパターンは避けるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Can I make a ref to a function component?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### 関数コンポーネントへの ref を作ることは可能ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While you shouldn't need this often, you may expose some imperative methods to a parent component with the [`useImperativeHandle`](/docs/hooks-reference.html#useimperativehandle) Hook.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>このようなことをする必要はあまりないはずですが、命令型のメソッドを親コンポーネントに公開するために [`useImperativeHandle`](/docs/hooks-reference.html#useimperativehandle) フックを利用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How can I measure a DOM node?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### DOM ノードの位置やサイズの測定はどのように行うのですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One rudimentary way to measure the position or size of a DOM node is to use a [callback ref](/docs/refs-and-the-dom.html#callback-refs).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>DOM ノードの位置やサイズを測定するための基本的な方法として、[コールバック形式の ref](/docs/refs-and-the-dom.html#callback-refs) が利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React will call that callback whenever the ref gets attached to a different node.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React は ref が異なるノードに割り当てられるたびにコールバックを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here is a [small demo](https://codesandbox.io/s/l7m0v5x4v9):</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>こちらの[小さなデモ](https://codesandbox.io/s/l7m0v5x4v9)をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We didn't choose `useRef` in this example because an object ref doesn't notify us about *changes* to the current ref value.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>この例で `useRef` を使わなかったのは、オブジェクト型の ref には現在値が変わった時にそれを通知する機能がないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a callback ref ensures that [even if a child component displays the measured node later](https://codesandbox.io/s/818zzk8m78) (e.g. in response to a click), we still get notified about it in the parent component and can update the measurements.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>コールバック ref を使うことで、[子コンポーネントが測定されたノードを（例えばクリックに応じて）後から表示する場合でも](https://codesandbox.io/s/818zzk8m78)、親コンポーネントの側でその変更について通知を受け取り、測定値を反映させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that we pass `[]` as a dependency array to `useCallback`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`useCallback` の依存値の配列として `[]` を渡したことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that our ref callback doesn't change between the re-renders, and so React won't call it unnecessarily.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これにより我々の ref コールバックが再レンダーごとに変化しないことが保証され、React が不必要にその関数を呼ばないで済みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the callback ref will be called only when the component mounts and unmounts, since the rendered `<it pos="begin" x="1">&lt;h1&gt;</it>` component stays present throughout any rerenders.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>この例では、レンダーされている `<it pos="begin" x="1">&lt;h1&gt;</it>` はどの再レンダー間でも同じように存在するため、コールバック ref はコンポーネントのマウント時とアンマウント時にのみ呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to be notified any time a component resizes, you may want to use [`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) or a third-party Hook built on it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>コンポーネントのリサイズが発生した際に毎回通知を受け取りたい場合は、[`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) や、これを使って作成されているサードパーティのフックの利用を検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want, you can [extract this logic](https://codesandbox.io/s/m5o42082xy) into a reusable Hook:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>お望みであれば再利用可能なフックとして[このロジックを抽出](https://codesandbox.io/s/m5o42082xy)できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### What does `const [thing, setThing] = useState()` mean?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### `const [thing, setThing] = useState()` というのはどういう意味ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're not familiar with this syntax, check out the [explanation](/docs/hooks-state.html#tip-what-do-square-brackets-mean) in the State Hook documentation.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>この構文に馴染みがない場合はステートフックのドキュメント内の[説明](/docs/hooks-state.html#tip-what-do-square-brackets-mean)をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Performance Optimizations {#performance-optimizations}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>## パフォーマンス最適化 {#performance-optimizations}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Can I skip an effect on updates?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### 更新時に副作用をスキップすることはできますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Yes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>はい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See [conditionally firing an effect](/docs/hooks-reference.html#conditionally-firing-an-effect).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>[条件付きで副作用を実行する](/docs/hooks-reference.html#conditionally-firing-an-effect)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that forgetting to handle updates often [introduces bugs](/docs/hooks-effect.html#explanation-why-effects-run-on-each-update), which is why this isn't the default behavior.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これがデフォルトの動作になっていないのは、更新時の対応を忘れることが[バグの元になる](/docs/hooks-effect.html#explanation-why-effects-run-on-each-update)からです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Is it safe to omit functions from the list of dependencies?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### 依存の配列から関数を省略しても大丈夫ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generally speaking, no.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>いいえ、一般的には省略できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's difficult to remember which props or state are used by functions outside of the effect.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>副作用関数の外側にある関数内でどの props や state が使われているのか覚えておくのは大変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is why **usually you'll want to declare functions needed by an effect *inside* of it.** Then it's easy to see what values from the component scope that effect depends on:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>ですので**副作用関数内で使われる関数は副作用関数内で宣言する**のがよいでしょう。そうすればコンポーネントスコープ内のどの値に副作用が依存しているのかを把握するのは容易です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If after that we still don't use any values from the component scope, it's safe to specify `[]`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>このようにした後で、やはりコンポーネントスコープ内のどの値も使用していないのであれば、`[]` を指定することは安全です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Depending on your use case, there are a few more options described below.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>ユースケースによっては、以下に述べるような選択肢もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;Note
&gt;
&gt;We provide the [`exhaustive-deps`](https://github.com/facebook/react/issues/14920) ESLint rule as a part of the [`eslint-plugin-react-hooks`](https://www.npmjs.com/package/eslint-plugin-react-hooks#installation) package.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>&gt;補足
&gt;
&gt; [`eslint-plugin-react-hooks`](https://www.npmjs.com/package/eslint-plugin-react-hooks#installation) パッケージの一部として [`exhaustive-deps`](https://github.com/facebook/react/issues/14920) という ESLint のルールを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It helps you find components that don't handle updates consistently.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>更新の一貫性が保たれていないコンポーネントを見つけるのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's see why this matters.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これがなぜ重要なのか説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you specify a [list of dependencies](/docs/hooks-reference.html#conditionally-firing-an-effect) as the last argument to `useEffect`, `useLayoutEffect`, `useMemo`, `useCallback`, or `useImperativeHandle`, it must include all values that are used inside the callback and participate in the React data flow.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`useEffect`、`useLayoutEffect`、`useMemo`、`useCallback` あるいは `useImperativeHandle` の最後の引数として[依存する値のリスト](/docs/hooks-reference.html#conditionally-firing-an-effect)を渡す場合、コールバック内部で使われ React のデータの流れに関わる値が、すべて含まれている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That includes props, state, and anything derived from them.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>すなわち props や state およびそれらより派生するあらゆるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is **only** safe to omit a function from the dependency list if nothing in it (or the functions called by it) references props, state, or values derived from them.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>関数を依存のリストから安全に省略できるのは、その関数（あるいはその関数から呼ばれる関数）が props、state ないしそれらから派生する値のいずれも含んでいない場合**のみ**です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example has a bug:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>以下の例にはバグがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**The recommended fix is to move that function _inside_ of your effect**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>**推奨される修正方法は、この関数を副作用*内*に移動することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That makes it easy to see which props or state your effect uses, and to ensure they're all declared:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>**これにより、副作用がどの props や state を利用しているのか把握しやすくなり、それらが指定されていることを保証しやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This also allows you to handle out-of-order responses with a local variable inside the effect:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これにより、要らなくなったレスポンスに対して副作用内でローカル変数を使って対処することも可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We moved the function inside the effect so it doesn't need to be in its dependency list.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>副作用内に関数を移動したことで、依存リスト内にこの関数を含めないでよくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;Tip
&gt;
&gt;Check out [this small demo](https://codesandbox.io/s/jvvkoo8pq3) and [this article](https://www.robinwieruch.de/react-hooks-fetch-data/) to learn more about data fetching with Hooks.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>&gt;ヒント
&gt;
&gt;フックでデータを取得する方法について[こちらの小さなデモ](https://codesandbox.io/s/jvvkoo8pq3)および[こちらの記事](https://www.robinwieruch.de/react-hooks-fetch-data/)をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**If for some reason you _can't_ move a function inside an effect, there are a few more options:**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>**何らかの理由で副作用内に関数を移動*できない*という場合、他にとりうる選択肢がいくつかあります。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **You can try moving that function outside of your component**.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* **そのコンポーネントの外部にその関数を移動できないか考えましょう**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In that case, the function is guaranteed to not reference any props or state, and also doesn't need to be in the list of dependencies.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>その場合、関数は props や state を参照していないことが保証されるので、依存のリストに含まずに済むようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* If the function you're calling is a pure computation and is safe to call while rendering, you may **call it outside of the effect instead,** and make the effect depend on the returned value.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* 使おうとしている関数が純粋な計算のみを行い、レンダー中に呼んで構わないものであるなら、その関数を代わりに**副作用の外部で呼ぶ**ようにして、副作用中ではその返り値に依存するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* As a last resort, you can **add a function to effect dependencies but _wrap its definition_** into the [`useCallback`](/docs/hooks-reference.html#usecallback) Hook.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* 最終手段として、関数を依存リストに加えつつ、[`useCallback`](/docs/hooks-reference.html#usecallback) を使って**その定義をラップする**ことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures it doesn't change on every render unless *its own* dependencies also change:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これにより、*関数自体*の依存が変わらない限り関数も変化しないことを保証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that in the above example we **need** to keep the function in the dependencies list.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>上記の例では関数を依存リストに含める**必要がある**ことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that a change in the `productId` prop of `ProductPage` automatically triggers a refetch in the `ProductDetails` component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これにより `ProductPage` の `productId` プロパティが変化した場合に自動的に `ProductDetail` コンポーネント内でデータの再取得が発生するようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### What can I do if my effect dependencies change too often?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### 副作用の依存リストが頻繁に変わりすぎる場合はどうすればよいですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sometimes, your effect may be using state that changes too often.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>しばしば、ある副作用がとても頻繁に変化する state を利用しないといけない場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You might be tempted to omit that state from a list of dependencies, but that usually leads to bugs:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>依存のリストからその state を省略したくなるかもしれませんが、通常それはバグになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The empty set of dependencies, `[]`, means that the effect will only run once when the component mounts, and not on every re-render.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>依存のリストが空であるということ (`[]`) は、コンポーネントのマウント時に副作用が一度のみ実行され、毎回の再レンダー時には実行されないということを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The problem is that inside the `setInterval` callback, the value of `count` does not change, because we've created a closure with the value of `count` set to `0` as it was when the effect callback ran.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>ここでの問題は、副作用コールバックが実行された時点で `count` の値が `0` に設定されたクロージャを作成したため、`setInterval` 内のコールバックで `count` の値が変わらなくなってしまう、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every second, this callback then calls `setCount(0 + 1)`, so the count never goes above 1.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>毎秒ごとにこのコールバックは `setCount(0 + 1)` を呼び出すので、カウントは 1 のまま変わらなくなってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifying `[count]` as a list of dependencies would fix the bug, but would cause the interval to be reset on every change.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>依存のリストとして `[count]` を指定すればバグは起きなくなりますが、その場合値が変化するたびにタイマーがリセットされることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Effectively, each `setInterval` would get one chance to execute before being cleared (similar to a `setTimeout`.) That may not be desirable.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>事実上それぞれの `setInterval` は一度しか実行されずに（`setTimeout` のように）クリアされてしまうのです。これは望ましい動作ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To fix this, we can use the [functional update form of `setState`](/docs/hooks-reference.html#functional-updates).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これを修正するため、[`setState` 関数形式による更新](/docs/hooks-reference.html#functional-updates)を利用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It lets us specify *how* the state needs to change without referencing the *current* state:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これにより state の*現在値*を参照せずに state が*どのように*更新されるべきかを指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The identity of the `setCount` function is guaranteed to be stable so it's safe to omit.)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>（`setCount` 関数については同一性が保たれることが保証されているので、省略して構いません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now, the `setInterval` callback executes once a second, but each time the inner call to `setCount` can use an up-to-date value for `count` (called `c` in the callback here.)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これで、`setInterval` のコールバックは 1 秒に 1 回実行されますが、内部の `setCount` は `count` の最新の値（この例では `c`）を参照できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In more complex cases (such as if one state depends on another state), try moving the state update logic outside the effect with the [`useReducer` Hook](/docs/hooks-reference.html#usereducer).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>より複雑なケース（ある state が別の state に依存している場合など）においては、state 更新のロジックを [`useReducer` フック](/docs/hooks-reference.html#usereducer)を使って副作用の外部に移動することを考慮してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>[This article](https://adamrackis.dev/state-and-use-reducer/) offers an example of how you can do this.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>[こちらの記事](https://adamrackis.dev/state-and-use-reducer/)にこのやり方についての例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**The identity of the `dispatch` function from `useReducer` is always stable** — even if the reducer function is declared inside the component and reads its props.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>**`useReducer` から返される `dispatch` 関数は常に同一性が保たれます**。これはリデューサ (reducer) 関数がコンポーネント内で宣言されており props を読み出している場合でも同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a last resort, if you want something like `this` in a class, you can [use a ref](/docs/hooks-faq.html#is-there-something-like-instance-variables) to hold a mutable variable.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>最終手段として、クラスにおける `this` のようなものが欲しい場合は、[ref](/docs/hooks-faq.html#is-there-something-like-instance-variables) を使ってミュータブルな値を保持させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Then you can write and read to it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>そうすればその値を読み書き可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only do this if you couldn't find a better alternative, as relying on mutation makes components less predictable.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>ミュータブルな値に依存することでコンポーネントの挙動が予測しづらくなるため、これは代替手段が思いつかない場合にのみ利用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there's a specific pattern that doesn't translate well, [file an issue](https://github.com/facebook/react/issues/new) with a runnable example code and we can try to help.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>うまくフックに移行できないパターンがあった場合は動作するコード例を添えて [issue を作成](https://github.com/facebook/react/issues/new)していただければお手伝いします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How do I implement `shouldComponentUpdate`?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### どうすれば `shouldComponentUpdate` を実装できますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can wrap a function component with `React.memo` to shallowly compare its props:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>関数コンポーネントを `React.memo` でラップして props を浅く比較するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's not a Hook because it doesn't compose like Hooks do.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これがフックになっていないのは、フックと違って組み合わせ可能ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>`React.memo` is equivalent to `PureComponent`, but it only compares props. (You can also add a second argument to specify a custom comparison function that takes the old and new props.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`React.memo` は `PureComponent` の同等物ですが、props のみを比較するという違いがあります（新旧の props を受け取るカスタムの比較関数を 2 つめの引数として加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it returns true, the update is skipped.)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>その関数が true を返した場合はコンポーネントの更新はスキップされます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>`React.memo` doesn't compare state because there is no single state object to compare.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`React.memo` は state を比較しませんが、これは比較可能な単一の state オブジェクトが存在しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But you can make children pure too, or even [optimize individual children with `useMemo`](/docs/hooks-faq.html#how-to-memoize-calculations).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>しかし子コンポーネント側も純粋にしておくことや、[`useMemo` を使って個々のコンポーネントを最適化する](/docs/hooks-faq.html#how-to-memoize-calculations)ことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How to memoize calculations?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### 計算結果のメモ化はどのように行うのですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The [`useMemo`](/docs/hooks-reference.html#usememo) Hook lets you cache calculations between multiple renders by "remembering" the previous computation:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>[`useMemo`](/docs/hooks-reference.html#usememo) フックを使うと、前の計算結果を「記憶」しておくことで、複数のレンダー間で計算結果をキャッシュすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This code calls `computeExpensiveValue(a, b)`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>このコードは `computeExpensiveValue(a, b)` を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But if the dependencies `[a, b]` haven't changed since the last value, `useMemo` skips calling it a second time and simply reuses the last value it returned.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>しかし依存である `[a, b]` の組み合わせが前回の値と変わっていない場合は、`useMemo` はこの関数の 2 回目の呼び出しをスキップし、単に前回返したのと同じ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remember that the function passed to `useMemo` runs during rendering.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`useMemo` に渡した関数はレンダー中に実行されるということを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don't do anything there that you wouldn't normally do while rendering.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>レンダー中に通常やらないようなことをやらないようにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, side effects belong in `useEffect`, not `useMemo`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>例えば副作用は `useMemo` ではなく `useEffect` の仕事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**You may rely on `useMemo` as a performance optimization, not as a semantic guarantee.** In the future, React may choose to "forget" some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>**`useMemo` はパフォーマンス最適化のために使うものであり、意味上の保証があるものだと考えないでください。**将来的に React は、例えば画面外のコンポーネント用のメモリを解放する、などの理由で、メモ化された値を「忘れる」ようにする可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write your code so that it still works without `useMemo` — and then add it to optimize performance.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`useMemo` なしでも動作するコードを書き、パフォーマンス最適化のために `useMemo` を加えるようにしましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(For rare cases when a value must *never* be recomputed, you can [lazily initialize](#how-to-create-expensive-objects-lazily) a ref.)</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>（値が*絶対に*再計算されてはいけないというような稀なケースでは、ref の[遅延初期化](#how-to-create-expensive-objects-lazily)を行うことができます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conveniently, `useMemo` also lets you skip an expensive re-render of a child:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>便利なことに、`useMemo` は子コンポーネントの計算量の高い再レンダーをスキップするのにも使えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that this approach won't work in a loop because Hook calls [can't](/docs/hooks-rules.html) be placed inside loops.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フック呼び出しはループ内に[配置できない](/docs/hooks-rules.html)ため、このアプローチはループ内では動作しないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But you can extract a separate component for the list item, and call `useMemo` there.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>ただしリストのアイテムの部分を別のコンポーネントに抽出してその中で `useMemo` を呼び出すことは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How to create expensive objects lazily?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### 計算量の大きいオブジェクトの作成を遅延する方法はありますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>`useMemo` lets you [memoize an expensive calculation](#how-to-memoize-calculations) if the dependencies are the same.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`useMemo` を使えば同じ値に依存している[高価な計算の結果をメモ化](#how-to-memoize-calculations)することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it only serves as a hint, and doesn't *guarantee* the computation won't re-run.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>しかしこれはあくまでヒントとして使われるものであり、計算が再実行されないということを*保証*しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But sometimes you need to be sure an object is only created once.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>しかし時にはオブジェクトが一度しか作られないことを保証したい場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**The first common use case is when creating the initial state is expensive:**</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>**まずよくあるユースケースは state の初期値を作成することが高価な場合です。**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To avoid re-creating the ignored initial state, we can pass a **function** to `useState`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>次回以降のレンダーでは無視される初期 state を毎回作成しなおすことを防ぐため、`useState` に**関数**を渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React will only call this function during the first render.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React は初回レンダー時のみこの関数を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See the [`useState` API reference](/docs/hooks-reference.html#usestate).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>[`useState` の API リファレンス](/docs/hooks-reference.html#usestate)を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>**You might also occasionally want to avoid re-creating the `useRef()` initial value.** For example, maybe you want to ensure some imperative class instance only gets created once:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>また、**まれに `useRef()` の初期値を毎回再作成することを避けたいということもあります。**例えば、命令型で作成するクラスのインスタンスが一度しか作成されないことを保証したいということがあるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>`useRef` **does not** accept a special function overload like `useState`.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`useRef` は `useState` のような関数を渡す形式のオーバーロード記法が**使えません**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, you can write your own function that creates and sets it lazily:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>代わりに、自分で関数を書いて高価なオブジェクトを遅延型で ref に設定することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This avoids creating an expensive object until it's truly needed for the first time.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これにより、本当に必要になるまで高価なオブジェクトの作成を避けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use Flow or TypeScript, you can also give `getObserver()` a non-nullable type for convenience.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>Flow や TypeScript を使っているなら、`getObserver()` を non-nullable な型にしておくと便利でしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### Are Hooks slow because of creating functions in render?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### レンダー内で関数を作るせいでフックは遅くなるのではないですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>いいえ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In modern browsers, the raw performance of closures compared to classes doesn't differ significantly except in extreme scenarios.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>モダンブラウザでは、特殊な場合を除いて、クラスと比較してクロージャーの生の性能はそれほど変わりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, consider that the design of Hooks is more efficient in a couple ways:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>しかも、フックの設計は幾つかの点においてはより効率的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Hooks avoid a lot of the overhead that classes require, like the cost of creating class instances and binding event handlers in the constructor.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* フックを使えば、クラスインスタンスの作成や、コンストラクタでのイベントハンドラのバインドといった、クラスの場合に必要な様々なオーバーヘッドを回避できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* **Idiomatic code using Hooks doesn't need the deep component tree nesting** that is prevalent in codebases that use higher-order components, render props, and context.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* フックをうまく用いたコードは、高階コンポーネントやレンダープロップやコンテクストを多用するコードベースで見られるような**深いコンポーネントのネストを必要としません**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With smaller component trees, React has less work to do.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>コンポーネントツリーが小さければ、React がやるべき仕事も減ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Traditionally, performance concerns around inline functions in React have been related to how passing new callbacks on each render breaks `shouldComponentUpdate` optimizations in child components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>過去には、インライン関数によるパフォーマンスの懸念というのは、レンダー毎に新しいコールバック関数を作って渡すと子コンポーネントでの `shouldComponentUpdate` による最適化が動かなくなる、という問題と関連していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hooks approach this problem from three sides.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フックではこの問題について 3 つの側面から対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The [`useCallback`](/docs/hooks-reference.html#usecallback) Hook lets you keep the same callback reference between re-renders so that `shouldComponentUpdate` continues to work:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [`useCallback`](/docs/hooks-reference.html#usecallback) フックを使えば再レンダーをまたいで同じコールバックを保持できるので、`shouldComponentUpdate` がうまく動作し続けます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* The [`useMemo`](/docs/hooks-faq.html#how-to-memoize-calculations) Hook makes it easier to control when individual children update, reducing the need for pure components.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [`useMemo`](/docs/hooks-faq.html#how-to-memoize-calculations) フックを使うことで個々の子コンポーネントをいつ更新するのかを制御しやすくなるため、コンポーネントが純粋である必要性は低くなっています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Finally, the [`useReducer`](/docs/hooks-reference.html#usereducer) Hook reduces the need to pass callbacks deeply, as explained below.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* 最後に、以下で説明されているように、[`useReducer`](/docs/hooks-reference.html#usereducer) フックを使えば、複数のコールバックを深い階層に受け渡していく必要があまりなくなります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How to avoid passing callbacks down?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### どうすれば複数のコールバックを深く受け渡すのを回避できますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We've found that most people don't enjoy manually passing callbacks through every level of a component tree.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>我々が見たところ、ほとんどの人はコンポーネントツリーの各階層で手作業でコールバックを受け渡ししていく作業が好きではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though it is more explicit, it can feel like a lot of "plumbing".</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>それはより明示的ではありますが、面倒な『配管工事』をしている気分になることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In large component trees, an alternative we recommend is to pass down a `dispatch` function from [`useReducer`](/docs/hooks-reference.html#usereducer) via context:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>大きなコンポーネントツリーにおいて我々がお勧めする代替手段は、[`useReducer`](/docs/hooks-reference.html#usereducer) で `dispatch` 関数を作って、それをコンテクスト経由で下の階層に渡す、というものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any child in the tree inside `TodosApp` can use the `dispatch` function to pass actions up to `TodosApp`:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>`TodosApp` ツリーの中にいるあらゆる子コンポーネントはこの `dispatch` 関数を使うことができ、上位にいる `TodosApp` にアクションを伝えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is both more convenient from the maintenance perspective (no need to keep forwarding callbacks), and avoids the callback problem altogether.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これは（複数のコールバックを何度も受け渡しする必要がないので）メンテナンスの観点から便利だ、というだけではなく、コールバックにまつわる問題をすべて回避できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Passing `dispatch` down like this is the recommended pattern for deep updates.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>深い更新においてはこのように `dispatch` を渡すのがお勧めのパターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that you can still choose whether to pass the application *state* down as props (more explicit) or as context (more convenient for very deep updates).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>アプリケーションの **state** については、props として渡していくか（より明示的）、あるいはコンテクスト経由で渡すか（深い更新ではより便利）を選ぶ余地が依然あります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use context to pass down the state too, use two different context types -- the `dispatch` context never changes, so components that read it don't need to rerender unless they also need the application state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>もしもコンテクストを使って state も渡すことにする場合は、2 つの別のコンテクストのタイプを使ってください -- `dispatch` のコンテクストは決して変わらないため、`dispatch` だけを使うコンポーネントは（アプリケーションの state も必要でない限り）再レンダーする必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How to read an often-changing value from `useCallback`?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### `useCallback` からの頻繁に変わる値を読み出す方法は？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;Note
&gt;
&gt;We recommend to [pass `dispatch` down in context](#how-to-avoid-passing-callbacks-down) rather than individual callbacks in props.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>&gt; 補足
&gt;
&gt; 我々は個別のコールバックを props として渡すのではなく、[コンテクスト経由で `dispatch` を渡す](#how-to-avoid-passing-callbacks-down)ことを推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The approach below is only mentioned here for completeness and as an escape hatch.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>以下のアプローチは網羅性と避難ハッチの目的で掲載しているものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&gt;
&gt;Also note that this pattern might cause problems in the [concurrent mode](/blog/2018/03/27/update-on-async-rendering.html).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>&gt;
&gt; また、[concurrent mode](/blog/2018/03/27/update-on-async-rendering.html) においてこのパターンは問題を起こす可能性があることにも注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We plan to provide more ergonomic alternatives in the future, but the safest solution right now is to always invalidate the callback if some value it depends on changes.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>将来的にはより使いやすい代替手段を提供することを計画していますが、現時点での最も安全な解決法は、コールバックが依存している何らかの値が変わった場合はコールバックを無効化して作り直すことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In some rare cases you might need to memoize a callback with [`useCallback`](/docs/hooks-reference.html#usecallback) but the memoization doesn't work very well because the inner function has to be re-created too often.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>稀なケースですが、コールバックを [`useCallback`](/docs/hooks-reference.html#usecallback) でメモ化しているにも関わらず、内部関数を何度も再作成しないといけないためメモ化がうまく働かない、ということがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the function you're memoizing is an event handler and isn't used during rendering, you can use [ref as an instance variable](#is-there-something-like-instance-variables), and save the last committed value into it manually:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>あなたがメモ化しようとしている関数がレンダー最中には使われないイベントハンドラなのであれば、[インスタンス変数としての ref](#is-there-something-like-instance-variables) を使って最後に使われた値を手動で保持しておくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a rather convoluted pattern but it shows that you can do this escape hatch optimization if you need it.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これはやや複雑なパターンですが、このような避難ハッチ的最適化は必要であれば可能だということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's more bearable if you extract it to a custom Hook:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>カスタムフックに抽出すれば多少は読みやすくなります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In either case, we **don't recommend this pattern** and only show it here for completeness.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>いずれにせよ、**このパターンは薦められず**、網羅性のために示しているに過ぎません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, it is preferable to [avoid passing callbacks deep down](#how-to-avoid-passing-callbacks-down).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>代わりに[コールバックを深く受け渡していくことを回避する](#how-to-avoid-passing-callbacks-down)のが望ましいパターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>## Under the Hood {#under-the-hood}</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>## 内部の仕組み {#under-the-hood}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### How does React associate Hook calls with components?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### React はフック呼び出しとコンポーネントとをどのように関連付けているのですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React keeps track of the currently rendering component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>React は現在どのコンポーネントがレンダー中なのかを把握しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Thanks to the [Rules of Hooks](/docs/hooks-rules.html), we know that Hooks are only called from React components (or custom Hooks -- which are also only called from React components).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>[フックのルール](/docs/hooks-rules.html)のお陰で、フックは React のコンポーネント内（あるいはそれらから呼び出されるカスタムフック内）でのみ呼び出されるということが分かっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is an internal list of "memory cells" associated with each component.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>それぞれのコンポーネントに関連付けられる形で、React 内に「メモリーセル」のリストが存在しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They're just JavaScript objects where we can put some data.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>それらは単に何らかのデータを保存できる JavaScript のオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you call a Hook like `useState()`, it reads the current cell (or initializes it during the first render), and then moves the pointer to the next one.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>あなたが `useState()` のようなフックを呼ぶと、フックは現在のセルの値を読み出し（あるいは初回レンダー時はセル内容を初期化し）、ポインタを次に進めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is how multiple `useState()` calls each get independent local state.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>これが複数の `useState()` の呼び出しが個別のローカル state を得る仕組みです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>### What is the prior art for Hooks?</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>### フックの先行技術にはどのようなものがありますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hooks synthesize ideas from several different sources:</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フックは複数の異なった出典からのアイディアを総合したものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* Our old experiments with functional APIs in the [react-future](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State) repository.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [react-future](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State) リポジトリにおける関数型 API の古い実験。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* React community's experiments with render prop APIs, including [Ryan Florence](https://github.com/ryanflorence)'s [Reactions Component](https://github.com/reactions/component).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [Ryan Florence](https://github.com/ryanflorence) の [Reactions Component](https://github.com/reactions/component) を含む、React コミュニティのレンダープロップ API に関する実験。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Dominic Gannaway](https://github.com/trueadm)'s [`adopt` keyword](https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067) proposal as a sugar syntax for render props.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [Dominic Gannaway](https://github.com/trueadm) によって提案された、レンダープロップの糖衣構文としての [`adopt` keyword](https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* State variables and state cells in [DisplayScript](http://displayscript.org/introduction.html).</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* [DisplayScript](http://displayscript.org/introduction.html) のステート変数とステートセル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Reducer components](https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html) in ReasonReact.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* ReasonReact の [Reducer components](https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Subscriptions](http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html) in Rx.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* Rx の [Subscriptions](http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>* [Algebraic effects](https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting) in Multicore OCaml.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>* Multicore OCaml の [Algebraic effects](https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>[Sebastian Markbåge](https://github.com/sebmarkbage) came up with the original design for Hooks, later refined by [Andrew Clark](https://github.com/acdlite), [Sophie Alpert](https://github.com/sophiebits), [Dominic Gannaway](https://github.com/trueadm), and other members of the React team.</seg>
      </tuv>
      <tuv xml:lang="ja" creationid="OmegaT Aligner" creationdate="20210727T055927Z">
        <seg>フックは [Sebastian Markbåge](https://github.com/sebmarkbage) が最初のデザインを作り、[Andrew Clark](https://github.com/acdlite)、[Sophie Alpert](https://github.com/sophiebits)、[Dominic Gannaway](https://github.com/trueadm) およびその他の React チームのメンバーが洗練させました。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
